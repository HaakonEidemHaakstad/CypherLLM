<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>CypherLLM</title>
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, viewport-fit=cover"
        />
        <link
            rel="icon"
            type="image/png"
            href="data:image/png;base64,uf/5Rxx99Bg1LFlE6GRmLd56+m1DYiXKBGVJs93QW8NgMAjeZG3CsFZIVos1s5spJydHVOMhXniqqsDaEYOqIpcJxvT89P/+U+yio72cQa3BK9I8C8McCX3bUntLbzRehoHo9dVllD9Du62hN6z6HiF3MT+CruuwNgB7sI60yCmrHNtpetvRNA2DwQCmH1iuFwihaEyHMx29TSiSjF53mC4oy/qo3LBNi0PFbaokHw45mhySKMXNqwsG1TBa7TSeSHy3oLIML0MahXCevu+xfYc1BhF5NLuCpswLkILOhMYdIBECmSqMCWd+LhOamzm/+ulfkQ8KNrMpv7q4RqY5qRNcX19A7ZGJo61buq7j4eMnoblebslkit5Y/uZf/V+ITPF7//g3GA5LpJR8cOuQUTxKg2Iu95Qnh+RHFbZSmCJEDXZOI7WPQGGLkIIs/pxN14Tta/Q7BoBlBqkgUUkEC4Z4sbptKcoMRVBu6N7jrSd1KZvVhswlITY0Dnk6a+icwePQ1rDaNmgcfVMjE4kxHQdVzlA5RigejytGznK/SEg0jFN48cuaf/nP/4TN1CIp8SYu5E1gNmAt3mm87oI0w9jQQNrAYwgFn41bfht696g0VAKss3u13C5jWopg65DYfU/t7/r+o9R/x1Ly0esv3C0TABftAHGTvWsapZQ4bwIo1fsI0U1+YHy/Q7+OdRDGUw1LVps1VZLdicESdzZnbl/i3a4W5H7j5vdWhSCt/570VoQmMQD5RCzzzA+UAvGlE9/fMjts+PIRKhwSreIw1drb9/ue4n0be303tWA/pJC3Gz+pbmXA3u5eowCilEE3gbM+2K28DH9JOLavLvnT//NPePA7nzJ6dsTjhw+5vr5kPp8zKoY8OX3Amxff8u3Xf4tbb5BJwXY6Y3U45HhYhm27i9YHET3FhO852cXn7QZAkbqdZQlpGs5FbU0YhNoYpb2La4wN+830mtP6CDmq8J0n9YbZh3cBmNZuoTFsLj/g356zsYLtwQEHj+7x5NkzXn3zNfW7JYMbw7pexahb/3fI6WHB5PdNUThxkzi0SqI4QONJkFlIJcF7RqNAoJ8ub0Lf0ME3v/gV7y4+0NZbaBuQgvLeCT5t+erP/4wbv+aGhs9//ScBOKjAd9uwtbaapq4xfYvzgtn0JkQDdj1z5zg4GFONDxmUA3Td8WG5Yvb6HL/aQNPhas3bb1/S1g3ryxtoDRiLSMPSbztf8os//0um51dslzOoe5CG81dvOTo75enpQy6uLmBVM3OGi/NLRJWwXKxxqy3z8yvevXyLX2/oNjXdeotZrDBO8mrbcfzwIY13XNxMeT+fMT6YUFUVj58+5vLmkqvpjKKocEnLYKB4v3wdFQ/BgpGmKb0JvVzXNuimDrVEb7AyieriFLep6aNdiKbGJQnVsOBwVHHZN/gELHc202nJk8cPuXnzhtV8yc3NNcfFKMjrdQ99T902AXrpPZtmS14UQRFMHGQ5Heakd8j84b2nAi9n2/PVX/0CUwmyewPerd4iSsOzL55x/9FjRJdx8bOv+fqP/hxmbfD8o+jaLlrQRVRR3Ur9pRR/Jwp0lwD3d0aU7vtWqzCwDkMCsoKsKPaKoDRLghJHyPj+Df1swNr5qIBSeMyeD0AEv1pngzI1+vhR4I3ZK4/CoNiB9cEGJHyECAdbnIzpLbrvSazuSMNpirUOmajQuGeKrMzYaQmVDF5sESVfRSFQTtLoGgO4PuQPeun3eaz7g3Pv73V70ErbtnHfHD6vMQbnIS2ScPAIj/QOJzxShCYmRL7s7wr8ztkUZXVFUVDmRTjUZQIqQR2MODg5Yqs88/mUNCtQUtHN5+jZFGk9g2qE1ppRXobJSJZxOBnRLDq2N5vYnJoQVSPj9MeHvM5gAnYhjiuSc4URSC1Yf3vBN9cb1ssVXM3DdFYIFvIiTIWSLAD98gQKRTff8O6b1xzljsvNjG2/ZXn9AZlKsqqkqXtuVuekSY6YhIlpX7ccDCZo06G3msS5/eBCqZBn6a27BUhEibiPmwScQCaRNClEiBfCxls5KC2CLyxOrKyPRYema5twqSYxikiJmMiQBS9NWWKMZuObQEXKVGhslAw578aAikAiJUhUGnkCgkR5jG4AE7yDWtCsFpBaqC3vX76kz3r6zQZmM8xsxt+0Hb/z9/4+j04fcN79DNqexBdUImPTub1lY/biLbwUyNMJjRD84t//BbXvWbeb4GPc9JSjCW9evMa+O2f15Amb80vab1+FCLFkwPT1W5Yf5sxX3/LWJeS9JK9GdNuG9v0FL376c7I8Yf72HOUltrPM3l6jXcfq4gOYnvXVlGSYh2HYagsyoX35nqu0YP5hxpPnn/Lk9CGblzd0MuNoVHH+5ipI66SiT9P9srverBDKkhYDQjRraP6TJEUrgVQpddfi8lAl6r4jEYF0bkUCEnKVMyyHJEOYmhnKSPpdPNO+8Alxa0pnOJdiO0vXdCy3a/I8p374CJEJNrrj5v0F7y/eUdcbTvuO1+/eMDwaMTg7xFzM6WZ1zHNNSPM0RPCIJJw54wo5zHFFiqhCI9UsNVqBHVWIVFEeH9GvW7KyQBQqwl+2wePcW4SLvszOh4ih3FEeDGjnFvmmoV/eUA0Kqplhfd6QaImZatgqaDTSBYsK0uOdjHEswW/WdwaVpeH8CsiuQO8VYZiTOIVpQ8GH3eKsgiKB1qCMJbUSv/XYVQ+1o1mvER2YTRsGgj7AV/ERMCokUiRoa5AqjR6xZH8YtnVHV3fYrg/PedtGuFUSJ+UyAmOARGKFg9SSPhrz3/xP/y3JseTdfMNi25BnI/q2RxhQVtBtWta2pZkt6aczeiEgEdw4QVNvyLygmU7pTfAcNstVOC+GOaLKOHn2gGXf0M8bqoMxTd3Q95r1ckOzqunTjgUErxqWoiyZFBXTxYy6CQA4awzb9YZBEaCO0+mU4WTEwcEYqWB5M0PUPfN3H+jnDaVTtK3dn8lWB5BQmhdBhhw98uVoSNMHJZAQApWGIieJd53ue7wQdE2L0X3Yzgp/C7Lbruhsh5eG7WrF0gdw3818FuR3waxPKlN0r6myHGRgXCSJxGuDFiGJJMlSHn30mHXXICvFUXJElRbMz69JVBIaOMDqQPsPahd5+/PZ0DwqKfHehRg0/J3Y3jt+375Hdz1ZGiCu3bZB5Qp0T6Pn2FUK9RoSia+GND6BxiAtwVPsBa7XIeq078EY+m1sGhT87A//mFFR8el/8inLw5LZcsGmMwzuj9He4VJHdjTAlgKfwcb3mCRuZhV4LzE+DE/LMkdrvX89RVwXChFSiZIsRUiLFwHCZm1oELwTaGvomp5SZiQ+ZTa7xm86fD5icHRCW9fIJCEbVti+xYnA80nyhDTJcTo0S1We4PuaQZXy9GDAoTFMEBQ2BJK8+hb+8F/8KYsbDa7AmbCRCht/E5y43t1udZzdb/md18HiiMO7283/bputhMRHa57YSfx3EbvRWuddtNLFjbbwd/89brljfep3Mnl3K6cPFgL/va3s7nlRSmDtruwV0fUXAZUOvAmbOWPMXu6vtaYsS5K7wLdoldopCbiTPCi/F7MXGlG3k/tjYzEcFiFYE8jxIcQQ6UMakicoWV1sKG0ckPCDyL5dXSNUGtKF3G1t5Nj5cMOAZaeI2H1vll2E9a7R93t/sBPso+32XzNaKCUicg3F/nXHpQE82Uj06w3vFr+guFex+Okrtk39/9H1Hj+WZml63++Yz10bPm3Zrmo3nBliZkhCoC"
        />

        <!-- Markdown parser -->
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

        <!-- Syntax highlighting -->
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

        <style>
            :root {
                --bg-main: #050816;
                --bg-chat: #111827;
                --bg-input: #020617;
                --border-subtle: #1f2933;
                --text-main: #e5e7eb;
                --text-muted: #9ca3af;
                --accent: #22c55e;
            }

            * {
                box-sizing: border-box;
            }

            /* Click effect for all buttons */
            button:active {
                transform: scale(0.95);
                transition: transform 0.1s ease;
            }
            html,
            body {
                height: 100%;
            }
            body {
                margin: 0;
                font-family:
                    system-ui,
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    sans-serif;
                background: radial-gradient(
                    circle at top,
                    #1f2937,
                    #020617 55%
                );
                color: var(--text-main);
                display: flex;
                justify-content: center;
                align-items: stretch;
                height: 100vh;
                overflow: hidden;
            }

            #app {
                display: flex;
                flex-direction: row;
                width: 100%;
                max-width: 1400px;
                margin: 16px;
                height: calc(100vh - 32px);
                max-height: calc(100vh - 32px);
                border-radius: 16px;
                background: linear-gradient(
                    145deg,
                    #020617,
                    #020617 40%,
                    #030712 100%
                );
                border: 1px solid var(--border-subtle);
                overflow: hidden;
                box-shadow:
                    0 20px 40px rgba(0, 0, 0, 0.7),
                    0 0 0 1px rgba(148, 163, 184, 0.1);
            }

            #main-content {
                display: flex;
                flex-direction: column;
                flex: 1;
                min-width: 0;
            }

            .settings-section {
                margin-bottom: 24px;
            }

            .settings-section:last-child {
                margin-bottom: 0;
            }

            .settings-label {
                display: block;
                margin-bottom: 8px;
                font-size: 12px;
                color: var(--text-main);
                font-weight: 600;
            }

            .settings-input {
                width: 100%;
                padding: 8px 12px;
                background: #020617;
                color: var(--text-main);
                border: 1px solid #1f2937;
                border-radius: 8px;
                font-family: inherit;
                font-size: 13px;
                outline: none;
            }

            .settings-input:focus {
                border-color: #3b82f6;
            }

            .settings-textarea {
                width: 100%;
                min-height: 400px;
                max-height: 600px;
                resize: vertical;
                padding: 10px 12px;
                background: #020617;
                color: var(--text-main);
                border: 1px solid #1f2937;
                border-radius: 8px;
                font-family: inherit;
                font-size: 12px;
                line-height: 1.5;
                outline: none;
            }

            .settings-textarea:focus {
                border-color: #3b82f6;
            }

            .settings-hint {
                margin-top: 6px;
                font-size: 11px;
                color: var(--text-muted);
                font-style: italic;
            }

            /* Settings View */
            #settings-view {
                display: none;
                flex-direction: column;
                flex: 1;
                overflow-y: auto;
                min-height: 0;
                position: relative;
            }

            #settings-view.visible {
                display: flex;
            }

            #settings-content {
                flex: 1;
                overflow-y: scroll;
                scrollbar-gutter: stable;
                padding: 8px 16px 16px 16px;
                display: flex;
                flex-direction: column;
                gap: 24px;
            }

            #settings-content::-webkit-scrollbar {
                width: 10px;
                -webkit-appearance: none;
            }

            #settings-content::-webkit-scrollbar-track {
                background: #0a0f1f;
                border-left: 1px solid #1f2937;
                border-radius: 8px;
                -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            }

            #settings-content::-webkit-scrollbar-thumb {
                background: linear-gradient(180deg, #1f2937, #111827);
                border-radius: 8px;
                border: 1px solid #4b5563;
                min-height: 30px;
            }

            #settings-content::-webkit-scrollbar-thumb:hover {
                background: linear-gradient(180deg, #374151, #1f2937);
                border-color: #6b7280;
            }

            .settings-section {
                margin-bottom: 24px;
            }

            .settings-section:first-child {
                margin-top: 0;
            }

            .settings-section:last-child {
                margin-bottom: 0;
            }

            .active-pagination {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 8px;
            }

            .active-pagination button {
                padding: 4px 10px;
                border-radius: 999px;
                border: 1px solid var(--border-subtle);
                background: #020617;
                color: var(--text-main);
                font-size: 12px;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 4px;
            }

            .active-pagination button:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }

            .active-pagination button:hover:not(:disabled) {
                background: #020617;
                border-color: #4b5563;
            }

            .active-pagination span {
                font-size: 12px;
                color: var(--text-muted);
            }

            .settings-label {
                display: block;
                margin-bottom: 8px;
                font-size: 12px;
                color: var(--text-main);
                font-weight: 600;
            }

            .settings-input {
                width: 100%;
                padding: 8px 12px;
                background: #020617;
                color: var(--text-main);
                border: 1px solid #1f2937;
                border-radius: 8px;
                font-family: inherit;
                font-size: 13px;
                outline: none;
            }

            .settings-input:focus {
                border-color: #3b82f6;
            }

            .settings-textarea {
                width: 100%;
                min-height: 400px;
                max-height: 600px;
                resize: vertical;
                padding: 10px 12px;
                background: #020617;
                color: var(--text-main);
                border: 1px solid #1f2937;
                border-radius: 8px;
                font-family: inherit;
                font-size: 12px;
                line-height: 1.5;
                outline: none;
            }

            .settings-textarea:focus {
                border-color: #3b82f6;
            }

            .settings-hint {
                margin-top: 6px;
                font-size: 11px;
                color: var(--text-muted);
                font-style: italic;
            }

            header {
                padding: 10px 16px;
                border-bottom: 1px solid var(--border-subtle);
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: radial-gradient(
                    circle at top left,
                    #0f172a,
                    #020617 60%
                );
            }

            header .title {
                font-size: 15px;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 8px;
                flex: 1;
            }

            #header-status {
                font-size: 12px;
                color: var(--text-muted);
                font-weight: 400;
                font-style: italic;
                margin-left: 8px;
                opacity: 0;
                transform: translateY(-10px);
                transition: all 0.3s ease;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 375px;
            }

            #header-status.show {
                opacity: 1;
                transform: translateY(0);
            }

            #header-status.fade-out {
                opacity: 0;
                transform: translateY(-5px);
            }

            #header-status.success {
                color: #22c55e;
            }

            #header-status.warning {
                color: #f59e0b;
            }

            #header-status.error {
                color: #ef4444;
            }

            header .dot {
                width: 10px;
                height: 10px;
                border-radius: 999px;
                background: var(--accent);
                box-shadow: 0 0 10px rgba(34, 197, 94, 0.8);
                transition:
                    background 0.3s ease,
                    box-shadow 0.3s ease;
                cursor: pointer;
            }

            header .dot.warning {
                background: #eab308;
                box-shadow: 0 0 10px rgba(234, 179, 8, 0.8);
            }

            header .dot.error {
                background: #ef4444;
                box-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
            }

            .status-log-dropdown {
                display: none;
                position: absolute;
                top: calc(100% + 8px);
                left: 0;
                background: linear-gradient(145deg, #0a0f1f, #020617 40%);
                border: 1px solid var(--border-subtle);
                border-radius: 8px;
                padding: 12px;
                z-index: 50;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.65);
                min-width: 350px;
                max-width: 450px;
            }

            .status-log-dropdown.visible {
                display: block;
            }

            .status-log-entry {
                font-size: 11px;
                padding: 6px 8px;
                border-radius: 4px;
                background: rgba(15, 23, 42, 0.5);
                border-left: 3px solid var(--border-subtle);
                word-wrap: break-word;
            }

            .status-log-entry.success {
                border-left-color: #22c55e;
                color: #86efac;
            }

            .status-log-entry.warning {
                border-left-color: #eab308;
                color: #fde047;
            }

            .status-log-entry.error {
                border-left-color: #ef4444;
                color: #fca5a5;
            }

            .status-log-entry .timestamp {
                font-size: 9px;
                color: var(--text-muted);
                margin-bottom: 2px;
            }

            .header-controls {
                display: flex;
                gap: 10px;
                align-items: center;
                flex-shrink: 0;
            }

            #api-link-btn {
                padding: 3px 10px;
                border-radius: 999px;
                border: 1px solid var(--border-subtle);
                background: #020617;
                color: var(--text-muted);
                font-size: 12px;
                cursor: pointer;
                text-decoration: none;
                display: inline-flex;
                align-items: center;
                gap: 4px;
            }

            #api-link-btn:hover {
                border-color: #4b5563;
                color: #e5e7eb;
            }

            .select-wrapper {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-size: 12px;
                color: var(--text-muted);
                padding: 2px 8px;
                border-radius: 999px;
                border: 1px solid var(--border-subtle);
                background: rgba(15, 23, 42, 0.9);
            }

            .label-text {
                font-size: 11px;
            }

            select {
                background: transparent;
                border: none;
                color: var(--text-main);
                font-size: 12px;
                font-family: inherit;
                outline: none;
                padding: 0 2px;
                cursor: pointer;
            }

            select option {
                background: #020617;
                color: var(--text-main);
            }

            /* Fixed width for model selector to prevent jumping */
            #model-select {
                width: 180px;
            }

            /* API key button in header */
            .api-key-btn {
                padding: 3px 10px;
                border-radius: 999px;
                border: 1px solid var(--border-subtle);
                background: #020617;
                color: var(--text-muted);
                font-size: 12px;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 4px;
                position: relative;
                vertical-align: middle;
            }

            .api-key-btn:hover {
                border-color: #4b5563;
                color: #e5e7eb;
            }

            .api-key-status {
                font-size: 8px;
                position: absolute;
                top: 2px;
                right: 2px;
            }

            .api-key-status.no-key {
                color: #ef4444;
            }

            .api-key-status.has-key {
                color: #f59e0b;
            }

            .api-key-status.valid-key {
                color: #22c55e;
            }

            /* Model settings button */
            .model-settings-btn {
                padding: 3px 10px;
                border-radius: 999px;
                border: 1px solid var(--border-subtle);
                background: #020617;
                color: var(--text-muted);
                font-size: 12px;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 4px;
                position: relative;
                vertical-align: middle;
            }

            .model-settings-btn:hover {
                border-color: #4b5563;
                color: #e5e7eb;
                background: #0a0f1f;
            }

            .model-settings-btn.active {
                border-color: #3b82f6;
                color: #3b82f6;
                background: rgba(59, 130, 246, 0.1);
            }

            /* Model settings dropdown */
            .model-settings-dropdown {
                display: none;
                position: absolute;
                top: calc(100% + 4px);
                right: 0;
                background: linear-gradient(145deg, #0a0f1f, #020617 40%);
                border: 1px solid var(--border-subtle);
                border-radius: 8px;
                padding: 12px;
                z-index: 50;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.65);
                min-width: 200px;
                flex-direction: column;
                gap: 12px;
            }

            .model-settings-dropdown.visible {
                display: flex;
            }

            .model-settings-row {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .model-settings-label {
                font-size: 11px;
                color: var(--text-muted);
                font-weight: 600;
            }

            /* Modal */
            .modal {
                display: none;
                position: fixed;
                z-index: 100;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.75);
                backdrop-filter: blur(4px);
            }

            .modal.show {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .modal-content {
                background: #020617;
                border: 1px solid #1f2937;
                border-radius: 12px;
                width: 90%;
                max-width: 500px;
                box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8);
            }

            .modal-header {
                padding: 16px 20px;
                border-bottom: 1px solid #1f2937;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .modal-header h3 {
                margin: 0;
                font-size: 16px;
                color: var(--text-main);
            }

            .modal-close-btn {
                background: transparent;
                border: none;
                color: var(--text-muted);
                font-size: 28px;
                cursor: pointer;
                padding: 0;
                width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                line-height: 1;
            }

            .modal-close-btn:hover {
                background: #1f2937;
                color: var(--text-main);
            }

            .modal-body {
                padding: 20px;
            }

            .modal-provider-info {
                margin-bottom: 16px;
                padding: 8px 12px;
                background: rgba(59, 130, 246, 0.1);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 8px;
                font-size: 13px;
            }

            .modal-provider-label {
                color: var(--text-muted);
                margin-right: 8px;
            }

            .modal-provider-name {
                color: #60a5fa;
                font-weight: 600;
            }

            .modal-label {
                display: block;
                margin-bottom: 8px;
                font-size: 13px;
                color: var(--text-main);
                font-weight: 600;
            }

            .modal-input-wrapper {
                display: flex;
                gap: 8px;
                margin-bottom: 12px;
            }

            .modal-input {
                flex: 1;
                padding: 8px 12px;
                background: #0a0f1f;
                color: var(--text-main);
                border: 1px solid #1f2937;
                border-radius: 8px;
                font-family: inherit;
                font-size: 13px;
                outline: none;
            }

            .modal-input:focus {
                border-color: #3b82f6;
            }

            .modal-toggle-btn {
                padding: 8px 12px;
                border-radius: 8px;
                border: 1px solid #1f2937;
                background: #020617;
                color: var(--text-muted);
                font-size: 14px;
                cursor: pointer;
            }

            .modal-toggle-btn:hover {
                border-color: #4b5563;
                background: #0a0f1f;
            }

            .modal-validation-status {
                font-size: 12px;
                padding: 8px 12px;
                border-radius: 6px;
                min-height: 36px;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .modal-validation-status.checking {
                background: rgba(59, 130, 246, 0.1);
                color: #60a5fa;
            }

            .modal-validation-status.valid {
                background: rgba(34, 197, 94, 0.1);
                color: #22c55e;
            }

            .modal-validation-status.invalid {
                background: rgba(239, 68, 68, 0.1);
                color: #ef4444;
            }

            .modal-footer {
                padding: 16px 20px;
                border-top: 1px solid #1f2937;
                display: flex;
                justify-content: flex-end;
                gap: 10px;
            }

            .modal-btn {
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 13px;
                font-weight: 600;
                cursor: pointer;
                border: none;
            }

            .modal-btn-secondary {
                background: #1f2937;
                color: var(--text-main);
            }

            .modal-btn-secondary:hover {
                background: #374151;
            }

            .modal-btn-primary {
                background: linear-gradient(135deg, #3b82f6, #60a5fa);
                color: white;
            }

            .modal-btn-primary:hover {
                background: linear-gradient(135deg, #2563eb, #3b82f6);
            }

            #chat-container {
                display: flex;
                flex-direction: column;
                flex: 1;
                min-height: 0;
                background: radial-gradient(
                    circle at top,
                    #020617,
                    #020617 55%
                );
                position: relative;
            }

            #pagination {
                display: flex;
                flex-direction: column;
                font-size: 11px;
                color: var(--text-muted);
                border-bottom: 1px solid var(--border-subtle);
                background: rgba(15, 23, 42, 0.8);
                backdrop-filter: blur(10px);
            }

            .pagination-controls {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 6px 16px;
            }

            .pagination-left {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .pagination-right {
                display: flex;
                align-items: center;
                gap: 6px;
                flex-wrap: wrap;
            }

            #pagination button {
                padding: 4px 10px;
                border-radius: 999px;
                border: 1px solid var(--border-subtle);
                background: #020617;
                color: var(--text-main);
                font-size: 11px;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 4px;
            }

            #pagination button:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }

            #pagination button:hover:not(:disabled) {
                background: #020617;
                border-color: #4b5563;
            }

            .toolbar-btn {
                padding: 3px 10px;
                border-radius: 999px;
                border: 1px solid var(--border-subtle);
                background: #020617;
                color: var(--text-muted);
                font-size: 11px;
                cursor: pointer;
            }

            .toolbar-btn:hover {
                border-color: #4b5563;
                color: #e5e7eb;
            }

            /* Context pairs input */
            .context-pairs-label {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                font-size: 11px;
                color: var(--text-muted);
            }

            .history-limit-wrapper {
                display: inline-flex;
                align-items: center;
                background: #020617;
                border: 1px solid var(--border-subtle);
                border-radius: 999px;
                overflow: hidden;
            }

            .history-limit-input {
                width: 36px;
                padding: 2px 4px;
                border: none;
                background: transparent;
                color: var(--text-main);
                font-size: 11px;
                text-align: center;
                outline: none;
            }

            /* Remove increment/decrement spinner buttons */
            .history-limit-input::-webkit-inner-spin-button,
            .history-limit-input::-webkit-outer-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }

            /* Remove spinner arrows from number inputs */
            input[type="number"]::-webkit-outer-spin-button,
            input[type="number"]::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }

            input[type="number"] {
                -moz-appearance: textfield;
            }

            .history-spinner-btn {
                width: 20px;
                height: 20px;
                padding: 0;
                border: none;
                background: linear-gradient(180deg, #1f2937, #111827);
                color: var(--text-main);
                font-size: 14px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                line-height: 1;
                transition: all 0.15s ease;
            }

            .history-spinner-btn:hover {
                background: linear-gradient(180deg, #374151, #1f2937);
            }

            .history-spinner-btn:active {
                transform: scale(0.95);
            }

            #status {
                padding: 4px 16px 0;
                font-size: 11px;
                color: var(--text-muted);
                min-height: 16px;
            }

            /* Attachments dropdown panel */
            #attachments {
                position: absolute;
                top: 42px;
                right: 16px;
                margin-top: 4px;
                background: #020617;
                border: 1px solid #1f2937;
                border-radius: 8px;
                padding: 6px 8px;
                z-index: 40;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.65);
                max-width: 260px;
                max-height: 220px;
                overflow-y: auto;
                display: none;
                font-size: 11px;
            }

            .attachments-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .attachment-pill {
                display: inline-flex;
                align-items: center;
                justify-content: space-between;
                gap: 6px;
                padding: 3px 8px;
                border-radius: 999px;
                border: 1px solid #1f2937;
                background: #020617;
                color: #e5e7eb;
            }

            .attachment-pill-label {
                white-space: nowrap;
                max-width: 180px;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .attachment-remove-btn {
                border: none;
                background: transparent;
                color: #9ca3af;
                cursor: pointer;
                font-size: 11px;
                padding: 0 2px;
            }

            .attachment-remove-btn:hover {
                color: #f97373;
            }

            #messages {
                flex: 1;
                min-height: 0;
                overflow-y: scroll;
                scrollbar-gutter: stable;
                padding: 8px 16px 16px;
            }

            .message-row {
                display: flex;
                gap: 12px;
                padding: 10px 0;
                border-bottom: none;
            }

            .message-row.assistant {
                border-bottom: 1px solid rgba(31, 41, 55, 0.8);
            }

            .message-row:last-child {
                border-bottom: none;
            }

            .avatar {
                width: 32px;
                height: 32px;
                border-radius: 999px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                flex-shrink: 0;
                overflow: hidden; /* For SVGs */
            }

            .avatar.user {
                background: linear-gradient(135deg, #2563eb, #4f46e5);
                color: white;
                cursor: pointer;
                transition: transform 0.2s ease;
            }

            .avatar.user:hover {
                transform: scale(1.1);
            }

            .avatar.user img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 999px;
            }

            /* Assistant Avatar Base */
            .avatar.assistant {
                background: #374151; /* Default/Fallback */
                color: #ffffff;
                font-size: 9px;
                padding: 0;
                cursor: pointer;
                transition: transform 0.2s ease;
            }

            .avatar.assistant:hover {
                transform: scale(1.1);
            }

            .avatar.assistant img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 999px;
            }

            .avatar.assistant.openai {
                background: #10a37f;
                color: #ffffff;
            }

            .avatar.assistant.google {
                background: linear-gradient(
                    135deg,
                    #4285f4,
                    #34a853,
                    #fbbc05,
                    #ea4335
                );
                color: #ffffff;
            }

            .avatar.assistant.anthropic {
                background: #d97757; /* Burnt orange for Claude */
                color: #ffffff;
            }

            .avatar.assistant.xai {
                background: #000000;
                border: 1px solid #333333;
                color: #ffffff;
            }

            .avatar.assistant.deepseek {
                background: #1e3a8a;
                color: #ffffff;
            }

            .avatar.assistant.perplexity {
                background: #1fb6ff;
                color: #ffffff;
            }

            .avatar.assistant.mistral {
                background: #ff7000;
                color: #ffffff;
            }

            .message-content {
                flex: 1;
                max-width: calc(100% - 64px);
            }

            .message-meta {
                font-size: 11px;
                color: var(--text-muted);
                margin-bottom: 4px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 8px;
                flex-wrap: wrap;
            }

            .meta-left {
                display: inline-flex;
                gap: 8px;
                align-items: center;
            }

            .include-toggle {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                font-size: 10px;
                color: var(--text-muted);
            }

            .include-toggle input[type="checkbox"] {
                width: 11px;
                height: 11px;
            }

            .message-bubble {
                padding: 10px 12px;
                border-radius: 12px;
                font-size: 14px;
                line-height: 1.6;
                white-space: pre-wrap;
                background: rgba(15, 23, 42, 0.95);
                border: 1px solid #1f2937;
            }

            .message-bubble.user {
                background: linear-gradient(
                    135deg,
                    rgba(37, 99, 235, 0.18),
                    rgba(59, 130, 246, 0.25)
                );
                border-color: rgba(129, 140, 248, 0.5);
            }

            .message-bubble.assistant {
                background: radial-gradient(
                    circle at top left,
                    rgba(34, 197, 94, 0.06),
                    #020617
                );
            }

            .message-bubble.assistant p {
                margin: 0 0 0.6em;
            }

            .message-bubble img {
                max-width: 100%;
                height: auto;
                border-radius: 8px;
                margin: 8px 0;
                border: 1px solid var(--border-subtle);
                display: block;
            }

            .message-bubble.assistant p:last-child {
                margin-bottom: 0;
            }

            .message-bubble.assistant ul,
            .message-bubble.assistant ol {
                padding-left: 18px;
                margin: 0 0 0.6em;
            }

            .message-bubble.assistant code {
                font-family:
                    ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                    "Liberation Mono", "Courier New", monospace;
                font-size: 13px;
                background: rgba(15, 23, 42, 0.9);
                padding: 2px 4px;
                border-radius: 4px;
            }

            /* Thinking bubble */
            .message-bubble.assistant.thinking {
                font-style: italic;
                opacity: 0.9;
            }

            .thinking-dots {
                display: inline-block;
                width: 1.5em;
                text-align: left;
            }

            .thinking-timer {
                display: inline-block;
                margin-left: 8px;
                font-size: 11px;
                color: #9ca3af;
                font-style: normal;
            }

            /* Code blocks */
            .message-bubble.assistant pre {
                position: relative;
                margin: 0.6em 0;
                padding-top: 30px;
                padding-bottom: 30px;
                border-radius: 10px;
                overflow: hidden;
                background: #020617;
                border: 1px solid #1e293b;
            }

            .message-bubble.assistant pre code {
                display: block;
                padding: 10px 12px 12px;
                background: transparent !important;
                overflow-x: auto;
            }

            .message-bubble.assistant pre.collapsed .code-footer {
                display: none;
            }

            .message-bubble.assistant pre.collapsed code {
                display: none;
            }

            .message-bubble.assistant pre.collapsed {
                height: 28px !important;
                overflow: hidden;
                padding: 0 !important;
                padding-top: 28px !important;
            }

            #messages::-webkit-scrollbar {
                width: 10px;
                -webkit-appearance: none;
            }

            #messages::-webkit-scrollbar-track {
                background: #0a0f1f;
                border-left: 1px solid #1f2937;
                border-radius: 8px;
                -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
            }

            #messages::-webkit-scrollbar-thumb {
                background: linear-gradient(180deg, #1f2937, #111827);
                border-radius: 8px;
                border: 1px solid #4b5563;
                min-height: 30px;
            }

            #messages::-webkit-scrollbar-thumb:hover {
                background: linear-gradient(180deg, #374151, #1f2937);
                border-color: #6b7280;
            }

            #messages {
                scrollbar-width: thin;
                scrollbar-color: #374151 #0a0f1f;
            }

            /* Make pending block visually match a single pairâ€™s divider */
            .pending-block {
                border-bottom: 1px solid rgba(31, 41, 55, 0.8);
            }

            /* Remove bottom border from the inner rows inside the pending block */
            .pending-block > .message-row {
                border-bottom: none;
            }

            /* Match input scrollbar to chat window */
            #user-input::-webkit-scrollbar {
                width: 10px;
            }

            #user-input::-webkit-scrollbar-track {
                background: #0a0f1f;
                border-left: 1px solid #1f2937;
                border-radius: 8px;
            }

            #user-input::-webkit-scrollbar-thumb {
                background: linear-gradient(180deg, #1f2937, #111827);
                border-radius: 8px;
                border: 1px solid #4b5563;
            }

            #user-input::-webkit-scrollbar-thumb:hover {
                background: linear-gradient(180deg, #374151, #1f2937);
                border-color: #6b7280;
            }

            /* Firefox scrollbar */
            #user-input {
                scrollbar-width: thin;
                scrollbar-color: #374151 #0a0f1f;
            }

            .code-header {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 28px;
                display: flex;
                align-items: center;
                justify-content: flex-start;
                padding: 0 10px;
                background: linear-gradient(90deg, #020617, #020617);
                border-bottom: 1px solid #1e293b;
                font-size: 11px;
                color: #9ca3af;
                z-index: 1;
                font-family: Consolas, "Courier New", monospace;
            }

            .code-header .ps-icon {
                display: inline-flex;
                align-items: center;
                gap: 2px;
                opacity: 0.85;
            }

            @keyframes blink-cursor {
                0% {
                    opacity: 1;
                }
                50% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }

            .code-header .ps-cursor {
                animation: blink-cursor 1s step-start infinite;
            }

            .code-header-controls {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                margin-left: auto;
            }

            .code-footer {
                position: absolute;
                left: 0;
                right: 0;
                bottom: 0;
                height: 28px;
                display: flex;
                align-items: center;
                justify-content: flex-end;
                gap: 6px;
                padding: 0 8px;
                background: linear-gradient(90deg, #020617, #020617);
                border-top: 1px solid #1e293b;
                font-size: 11px;
                color: #9ca3af;
            }

            .copy-btn {
                border: 1px solid #4b5563;
                border-radius: 999px;
                padding: 2px 8px;
                font-size: 11px;
                background: transparent;
                color: #9ca3af;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 4px;
            }

            .copy-btn:hover {
                background: #020617;
                color: #e5e7eb;
            }

            /* Input area */
            #input-area {
                border-top: 1px solid var(--border-subtle);
                background: var(--bg-input);
                padding: 14px 16px 14px 16px;
                position: relative;
            }

            #input-inner {
                display: flex;
                flex-direction: column;
                gap: 8px;
                background: #020617;
                border-radius: 12px;
                padding: 6px 8px 6px 14px;
                border: 1px solid #1f2937;
            }

            #input-controls {
                display: flex;
                gap: 8px;
                align-items: flex-end;
            }

            #user-input {
                flex: 1;
                border: none;
                outline: none;
                background: transparent;
                color: var(--text-main);
                font-size: 14px;
                resize: none;
                max-height: 240px;
                min-height: 24px;
                padding-top: 6px;
                padding-bottom: 6px;
                font-family: inherit;
                overflow-y: auto;
            }

            #attach-btn-input {
                border: none;
                border-radius: 999px;
                padding: 6px 12px;
                background: linear-gradient(135deg, #6366f1, #8b5cf6);
                color: white;
                font-weight: 600;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 13px;
                flex: 0 0 auto;
                height: 32px;
            }

            #attach-btn-input:hover {
                background: linear-gradient(135deg, #4f46e5, #7c3aed);
            }

            #settings-btn {
                border: 1px solid #374151;
                border-radius: 999px;
                padding: 6px 12px;
                background: #1f2937;
                color: var(--text-main);
                font-weight: 600;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                flex: 0 0 auto;
                height: 32px;
                transition: all 0.2s ease;
            }

            #settings-btn:hover {
                background: #374151;
                border-color: #4b5563;
            }

            #settings-btn.active {
                background: #ffffff;
                border-color: #ffffff;
                color: #1f2937;
            }

            .number-btn {
                border: 1px solid var(--border-subtle);
                border-radius: 4px;
                padding: 2px 8px;
                background: #020617;
                color: var(--text-main);
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                min-width: 24px;
                height: 24px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
            }

            .number-btn:hover {
                background: #0a0f1f;
                border-color: #4b5563;
            }

            .number-btn:active {
                background: #1f2937;
            }

            .number-btn-inline {
                padding: 4px 8px;
                border: 1px solid var(--border-subtle);
                background: #020617;
                color: var(--text-main);
                font-size: 11px;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                transition: background 0.15s ease;
                outline: none;
                position: relative;
                z-index: 1;
                min-width: 28px;
            }

            .number-btn-inline:hover {
                background: #0a0f1f;
            }

            .number-btn-inline:active {
                background: #1f2937;
            }

            .number-btn-inline:first-child {
                border-radius: 999px 0 0 999px;
            }

            .number-btn-inline:last-child {
                border-radius: 0 999px 999px 0;
            }

            #page-size-display:hover,
            #history-limit-display:hover {
                background: #0a0f1f;
                border-top-color: #4b5563;
                border-bottom-color: #4b5563;
            }

            #refresh-files-btn {
                border: none;
                border-radius: 999px;
                padding: 6px 12px;
                background: linear-gradient(135deg, #3b82f6, #60a5fa);
                color: white;
                font-weight: 600;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 13px;
                flex: 0 0 auto;
                height: 32px;
            }

            #refresh-files-btn:hover {
                background: linear-gradient(135deg, #2563eb, #3b82f6);
            }

            #input-attachments-list {
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
                padding: 4px 0;
                max-height: 80px;
                overflow-y: auto;
            }

            .input-attachment-pill {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 4px 10px;
                border-radius: 999px;
                border: 1px solid #1f2937;
                background: rgba(99, 102, 241, 0.1);
                color: #a5b4fc;
                font-size: 11px;
            }

            .input-attachment-remove {
                border: none;
                background: transparent;
                color: #9ca3af;
                cursor: pointer;
                font-size: 14px;
                padding: 0;
                line-height: 1;
            }

            .input-attachment-remove:hover {
                color: #f87171;
            }

            /* Refresh dropdown */
            #refresh-dropdown {
                position: absolute;
                background: #020617;
                border: 1px solid #1f2937;
                border-radius: 8px;
                padding: 8px;
                z-index: 1000;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.65);
                min-width: 250px;
                max-width: 300px;
                max-height: 250px;
                overflow-y: auto;
                display: none;
            }

            #refresh-dropdown.show {
                display: block;
            }

            .refresh-option {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 6px 8px;
                font-size: 12px;
                color: #e5e7eb;
                border-radius: 6px;
                cursor: pointer;
                margin-bottom: 4px;
            }

            .refresh-option:hover {
                background: rgba(59, 130, 246, 0.1);
            }

            .refresh-option input[type="checkbox"] {
                width: 14px;
                height: 14px;
                cursor: pointer;
            }

            .refresh-option-label {
                flex: 1;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .refresh-dropdown-actions {
                display: flex;
                gap: 6px;
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid #1f2937;
            }

            .refresh-dropdown-btn {
                flex: 1;
                padding: 4px 8px;
                border-radius: 6px;
                border: 1px solid #1f2937;
                background: #020617;
                color: #e5e7eb;
                font-size: 11px;
                cursor: pointer;
                height: 32px;
            }

            .refresh-dropdown-btn:hover {
                background: #1f2937;
            }

            .refresh-dropdown-btn.primary {
                background: linear-gradient(135deg, #3b82f6, #60a5fa);
                border-color: #3b82f6;
                color: white;
            }

            .refresh-dropdown-btn.primary:hover {
                background: linear-gradient(135deg, #2563eb, #3b82f6);
            }

            #send-btn {
                border: none;
                border-radius: 999px;
                padding: 6px 18px;
                background: linear-gradient(135deg, #22c55e, #4ade80);
                color: #052e16;
                font-weight: 600;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-size: 13px;
                flex: 0 0 auto;
                height: 32px;
            }

            #send-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            #stop-btn {
                border: none;
                border-radius: 999px;
                padding: 6px 18px;
                background: linear-gradient(135deg, #ef4444, #f87171);
                color: #ffffff;
                font-weight: 600;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-size: 13px;
                flex: 0 0 auto;
                height: 32px;
            }

            #stop-btn:hover {
                background: linear-gradient(135deg, #dc2626, #ef4444);
            }

            #stop-btn .icon {
                color: #ffffff;
            }

            #footer-hint {
                margin-top: 6px;
                font-size: 11px;
                color: var(--text-muted);
                display: flex;
                justify-content: space-between;
                gap: 8px;
                flex-wrap: wrap;
            }

            @media (max-width: 640px) {
                .message-content {
                    max-width: 100%;
                }

                #input-inner {
                    border-radius: 12px;
                }

                #input-area {
                    padding-bottom: calc(
                        40px + env(safe-area-inset-bottom, 0px)
                    );
                }

                header {
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 4px;
                }

                .header-controls {
                    flex-wrap: wrap;
                }

                .pagination-left,
                .pagination-right {
                    flex-wrap: wrap;
                }

                #footer-hint {
                    flex-direction: column;
                    align-items: flex-start;
                }
            }

            /* Collapsed pair styling */
            .message-row.collapsed-summary {
                border-bottom: 1px solid rgba(31, 41, 55, 0.8);
                font-size: 12px;
                color: var(--text-muted);
            }

            .collapsed-avatars {
                position: relative;
                width: 32px;
                height: 46px;
                flex-shrink: 0;
            }

            .collapsed-avatars .avatar {
                position: absolute;
                width: 32px;
                height: 32px;
            }

            .collapsed-avatars .avatar.user {
                top: 0;
                left: -4px;
                z-index: 1;
            }

            .collapsed-avatars .avatar.assistant {
                top: 14px;
                left: 4px;
                z-index: 2;
            }

            .collapsed-summary-bubble {
                padding: 6px 10px;
                border-radius: 10px;
                background: rgba(15, 23, 42, 0.9);
                border: 1px dashed #4b5563;
                font-size: 12px;
                color: var(--text-muted);
            }

            /* Back to top button */
            #back-to-top {
                position: absolute;
                bottom: 16px;
                right: 16px;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: linear-gradient(135deg, #22c55e, #4ade80);
                border: 1px solid rgba(34, 197, 94, 0.5);
                color: #052e16;
                font-size: 18px;
                cursor: pointer;
                display: none;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                z-index: 50;
                transition: all 0.3s ease;
            }

            #back-to-top:hover {
                background: linear-gradient(135deg, #16a34a, #22c55e);
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
            }

            #back-to-top.show {
                display: flex;
            }

            /* Drag and drop styles */
            #input-area.drag-over {
                background: rgba(99, 102, 241, 0.15);
                border-top: 2px solid #6366f1;
            }

            #input-inner.drag-over {
                background: rgba(99, 102, 241, 0.1);
                border: 2px dashed #6366f1;
                transform: scale(1.01);
                transition: all 0.2s ease;
            }

            .drag-drop-overlay {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(99, 102, 241, 0.05);
                border: 3px dashed #6366f1;
                border-radius: 12px;
                display: none;
                align-items: center;
                justify-content: center;
                pointer-events: none;
                z-index: 10;
            }

            .drag-drop-overlay.show {
                display: flex;
            }

            .drag-drop-text {
                font-size: 18px;
                font-weight: 600;
                color: #a5b4fc;
                text-align: center;
                padding: 20px;
                background: rgba(2, 6, 23, 0.95);
                border-radius: 12px;
                border: 1px solid #6366f1;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <!-- Main Content Area -->
            <div id="main-content">
                <header>
                    <div class="title">
                        <div style="position: relative; display: inline-block">
                            <div
                                class="dot"
                                id="status-dot"
                                title="Click to view status log"
                            ></div>
                            <div
                                id="status-log-dropdown"
                                class="status-log-dropdown"
                            >
                                <div
                                    style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        margin-bottom: 8px;
                                    "
                                >
                                    <span
                                        style="
                                            font-size: 11px;
                                            font-weight: 600;
                                            color: var(--text-muted);
                                        "
                                        >Status Log</span
                                    >
                                    <button
                                        id="clear-log-btn"
                                        style="
                                            font-size: 10px;
                                            padding: 2px 6px;
                                            background: transparent;
                                            border: 1px solid
                                                var(--border-subtle);
                                            border-radius: 4px;
                                            color: var(--text-muted);
                                            cursor: pointer;
                                        "
                                    >
                                        Clear
                                    </button>
                                </div>
                                <div
                                    id="status-log-content"
                                    style="
                                        max-height: 300px;
                                        overflow-y: auto;
                                        display: flex;
                                        flex-direction: column;
                                        gap: 6px;
                                    "
                                >
                                    <span
                                        style="
                                            font-size: 11px;
                                            color: var(--text-muted);
                                            font-style: italic;
                                        "
                                        >No messages yet</span
                                    >
                                </div>
                            </div>
                        </div>
                        <span>CypherLLM</span>
                        <span id="header-status"></span>
                    </div>
                    <div class="header-controls">
                        <div class="select-wrapper">
                            <span class="label-text">Provider:</span>
                            <select id="provider-select">
                                <option value="openai">OpenAI</option>
                                <option value="google">Google</option>
                                <option value="anthropic">Anthropic</option>
                                <option value="xai">xAI</option>
                                <option value="deepseek">DeepSeek</option>
                                <option value="perplexity">Perplexity</option>
                                <option value="mistral">Mistral</option>
                            </select>
                        </div>
                        <div class="select-wrapper">
                            <span class="label-text">Model:</span>
                            <select id="model-select">
                                <!-- Populated by JS -->
                            </select>
                        </div>
                        <div
                            style="
                                position: relative;
                                display: inline-block;
                                vertical-align: middle;
                                margin-bottom: 1px;
                            "
                        >
                            <button
                                id="model-settings-btn"
                                class="model-settings-btn"
                                title="Model Settings"
                            >
                                âš™
                            </button>
                            <div
                                id="model-settings-dropdown"
                                class="model-settings-dropdown"
                            >
                                <div
                                    class="model-settings-row"
                                    id="reasoning-row"
                                    style="display: none"
                                >
                                    <span class="model-settings-label"
                                        >Reasoning Effort:</span
                                    >
                                    <select
                                        id="reasoning-select-new"
                                        style="
                                            padding: 4px 8px;
                                            background: #020617;
                                            color: var(--text-main);
                                            border: 1px solid
                                                var(--border-subtle);
                                            border-radius: 4px;
                                            font-size: 12px;
                                            outline: none;
                                        "
                                    >
                                        <option value="none">
                                            None (omit)
                                        </option>
                                        <option value="minimal">Minimal</option>
                                        <option value="low">Low</option>
                                        <option value="medium">Medium</option>
                                        <option value="high">High</option>
                                    </select>
                                </div>
                                <div
                                    class="model-settings-row"
                                    id="verbosity-row"
                                    style="display: none"
                                >
                                    <span class="model-settings-label"
                                        >Verbosity:</span
                                    >
                                    <select
                                        id="verbosity-select-new"
                                        style="
                                            padding: 4px 8px;
                                            background: #020617;
                                            color: var(--text-main);
                                            border: 1px solid
                                                var(--border-subtle);
                                            border-radius: 4px;
                                            font-size: 12px;
                                            outline: none;
                                        "
                                    >
                                        <option value="low">Low</option>
                                        <option value="medium">Medium</option>
                                        <option value="high">High</option>
                                    </select>
                                </div>
                                <div
                                    class="model-settings-row"
                                    id="temperature-row"
                                    style="display: none"
                                >
                                    <span class="model-settings-label"
                                        >Temperature:</span
                                    >
                                    <input
                                        type="number"
                                        id="temperature-input-new"
                                        min="0"
                                        max="2"
                                        step="0.1"
                                        value="1.0"
                                        style="
                                            width: 100%;
                                            text-align: center;
                                            font-size: 12px;
                                            color: var(--text-main);
                                            background: #020617;
                                            border: 1px solid
                                                var(--border-subtle);
                                            border-radius: 4px;
                                            padding: 4px 8px;
                                            outline: none;
                                        "
                                    />
                                </div>
                            </div>
                        </div>
                        <div
                            style="
                                position: relative;
                                display: inline-block;
                                vertical-align: middle;
                                margin-bottom: 1px;
                            "
                        >
                            <button
                                id="api-key-btn"
                                class="api-key-btn"
                                title="Set API Key"
                            >
                                <span class="api-key-icon">ðŸ”‘</span>
                                <span id="api-key-status" class="api-key-status"
                                    >â—</span
                                >
                            </button>
                        </div>
                        <a
                            id="api-link-btn"
                            href="#"
                            target="_blank"
                            rel="noopener noreferrer"
                        >
                            ðŸ’° Credits
                        </a>
                    </div>
                </header>

                <!-- API Key Modal -->
                <div id="api-key-modal" class="modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>API Key Settings</h3>
                            <button
                                id="modal-close-btn"
                                class="modal-close-btn"
                            >
                                &times;
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="modal-provider-info">
                                <span class="modal-provider-label"
                                    >Provider:</span
                                >
                                <span
                                    id="modal-provider-name"
                                    class="modal-provider-name"
                                ></span>
                            </div>
                            <label for="modal-apikey-input" class="modal-label">
                                API Key:
                            </label>
                            <div class="modal-input-wrapper">
                                <input
                                    id="modal-apikey-input"
                                    type="password"
                                    placeholder="Enter API Key..."
                                    autocomplete="off"
                                    class="modal-input"
                                />
                                <button
                                    id="modal-toggle-visibility"
                                    class="modal-toggle-btn"
                                    title="Toggle visibility"
                                >
                                    ðŸ‘ï¸
                                </button>
                            </div>
                            <div
                                id="modal-validation-status"
                                class="modal-validation-status"
                            ></div>
                        </div>
                        <div class="modal-footer">
                            <button
                                id="modal-clear-btn"
                                class="modal-btn modal-btn-secondary"
                            >
                                Clear Key
                            </button>
                            <button
                                id="modal-save-btn"
                                class="modal-btn modal-btn-primary"
                            >
                                Save
                            </button>
                        </div>
                    </div>
                </div>

                <div id="chat-container">
                    <div id="pagination">
                        <div class="pagination-controls">
                            <div class="pagination-left">
                                <button id="next-page">&larr; Newer</button>
                                <span id="page-info">Page 1 / 1</span>
                                <button id="prev-page">Older &rarr;</button>

                                <span
                                    style="
                                        font-size: 11px;
                                        color: var(--text-muted);
                                        margin-left: 8px;
                                    "
                                    title="Number of conversation pairs to display per page (0 = unlimited)"
                                    >Per page:</span
                                >
                                <div
                                    style="
                                        display: inline-flex;
                                        align-items: center;
                                        margin: 0 -5px;
                                    "
                                >
                                    <button
                                        id="page-size-dec"
                                        class="number-btn-inline"
                                    >
                                        âˆ’
                                    </button>
                                    <input
                                        type="number"
                                        id="page-size-display"
                                        min="0"
                                        max="100"
                                        style="
                                            width: 40px;
                                            text-align: center;
                                            font-size: 11px;
                                            color: var(--text-main);
                                            background: #020617;
                                            border-top: 1px solid
                                                var(--border-subtle);
                                            border-bottom: 1px solid
                                                var(--border-subtle);
                                            border-left: none;
                                            border-right: none;
                                            padding: 4px 8px;
                                            outline: none;
                                            position: relative;
                                            z-index: 2;
                                            margin: 0 -8px;
                                        "
                                        title="Number of conversation pairs to display per page (0 = unlimited)"
                                        value="10"
                                    />
                                    <button
                                        id="page-size-inc"
                                        class="number-btn-inline"
                                    >
                                        +
                                    </button>
                                </div>

                                <span
                                    style="
                                        font-size: 11px;
                                        color: var(--text-muted);
                                        margin-left: 8px;
                                    "
                                    title="Maximum number of recent conversation pairs to include in context (0 = unlimited)"
                                    >Context limit:</span
                                >
                                <div
                                    style="
                                        display: inline-flex;
                                        align-items: center;
                                        margin: 0 -5px;
                                    "
                                >
                                    <button
                                        id="history-limit-dec"
                                        class="number-btn-inline"
                                    >
                                        âˆ’
                                    </button>
                                    <input
                                        type="number"
                                        id="history-limit-display"
                                        min="0"
                                        max="50"
                                        style="
                                            width: 40px;
                                            text-align: center;
                                            font-size: 11px;
                                            color: var(--text-main);
                                            background: #020617;
                                            border-top: 1px solid
                                                var(--border-subtle);
                                            border-bottom: 1px solid
                                                var(--border-subtle);
                                            border-left: none;
                                            border-right: none;
                                            padding: 4px 8px;
                                            outline: none;
                                            position: relative;
                                            z-index: 2;
                                            margin: 0 -8px;
                                        "
                                        title="Maximum number of recent conversation pairs to include in context (0 = unlimited)"
                                        value="12"
                                    />
                                    <button
                                        id="history-limit-inc"
                                        class="number-btn-inline"
                                    >
                                        +
                                    </button>
                                </div>
                            </div>
                            <div class="pagination-right">
                                <input
                                    type="file"
                                    id="attach-file-input"
                                    multiple
                                    style="display: none"
                                />

                                <button id="export-btn" class="toolbar-btn">
                                    Save
                                </button>
                                <button id="import-btn" class="toolbar-btn">
                                    Load
                                </button>
                                <button id="new-chat-btn" class="toolbar-btn">
                                    New
                                </button>
                                <input
                                    type="file"
                                    id="import-file"
                                    accept="application/json"
                                    style="display: none"
                                />
                                <input
                                    type="file"
                                    id="avatar-file-input"
                                    accept="image/*"
                                    style="display: none"
                                />
                            </div>
                        </div>
                    </div>
                    <div id="status"></div>
                    <div id="attachments"></div>
                    <div id="messages"></div>
                    <div id="settings-view">
                        <div id="settings-content">
                            <div
                                class="settings-section"
                                style="
                                    background: rgba(34, 197, 94, 0.1);
                                    border: 1px solid rgba(34, 197, 94, 0.3);
                                    border-radius: 8px;
                                    padding: 12px;
                                "
                            >
                                <label class="settings-label"
                                    >Estimated Token Usage</label
                                >
                                <div
                                    id="token-counter"
                                    style="
                                        font-size: 24px;
                                        font-weight: 600;
                                        color: var(--accent);
                                        margin-top: 8px;
                                    "
                                >
                                    Calculating...
                                </div>
                                <div
                                    style="
                                        font-size: 11px;
                                        color: var(--text-muted);
                                        margin-top: 4px;
                                    "
                                >
                                    System prompt + pinned pairs + active
                                    context pairs (~4 chars per token)
                                </div>
                            </div>

                            <div class="settings-section">
                                <label class="settings-label"
                                    >System Prompt / Context</label
                                >
                                <textarea
                                    id="settings-context-input"
                                    placeholder="You are an AI assistant..."
                                    class="settings-textarea"
                                    style="min-height: 200px; max-height: 350px"
                                ></textarea>
                                <div class="settings-hint">
                                    This prompt is sent with every request.
                                    Changes are saved automatically.
                                </div>
                            </div>

                            <div class="settings-section">
                                <label class="settings-label"
                                    >Pinned Context Pairs</label
                                >
                                <div
                                    id="settings-pinned-list"
                                    style="
                                        font-size: 12px;
                                        color: var(--text-muted);
                                    "
                                >
                                    No pinned pairs
                                </div>
                            </div>

                            <div class="settings-section">
                                <label class="settings-label"
                                    >Active Context Pairs</label
                                >
                                <div class="active-pagination">
                                    <button id="active-next-page">
                                        &larr; Newer
                                    </button>
                                    <span id="active-page-info"
                                        >Page 1 / 1</span
                                    >
                                    <button id="active-prev-page">
                                        Older &rarr;
                                    </button>
                                </div>
                                <div
                                    id="settings-active-list"
                                    style="
                                        font-size: 12px;
                                        color: var(--text-muted);
                                    "
                                >
                                    No active context pairs
                                </div>
                            </div>
                        </div>
                    </div>
                    <button id="back-to-top" title="Back to top">â†‘</button>
                </div>

                <div id="input-area">
                    <div class="drag-drop-overlay">
                        <div class="drag-drop-text">
                            ðŸ“„ Drop files here to attach
                        </div>
                    </div>
                    <div id="refresh-dropdown"></div>
                    <div id="input-inner">
                        <div id="input-attachments-list"></div>
                        <div id="input-controls">
                            <button id="attach-btn-input" title="Attach files">
                                ðŸ“„
                            </button>
                            <textarea
                                id="user-input"
                                placeholder="Send a message..."
                                rows="1"
                            ></textarea>
                            <button
                                id="refresh-files-btn"
                                style="display: none"
                                title="Refresh attachments"
                            >
                                ðŸ“„ â†»
                            </button>
                            <button id="settings-btn" title="Context Settings">
                                âš™
                                <span style="margin-left: 4px; font-size: 13px"
                                    >Context</span
                                >
                            </button>
                            <button id="send-btn">
                                <span class="icon">âž¤</span>
                                <span>Send</span>
                            </button>
                            <button id="stop-btn" style="display: none">
                                <span class="icon">â¬›</span>
                                <span>Stop</span>
                            </button>
                        </div>
                    </div>
                    <div id="footer-hint">
                        <span
                            >Press Enter to send Â· Shift+Enter for a new
                            line</span
                        >
                        <span
                            >Max 10 prompt/response pairs per page Â· Only
                            checked pairs are used as context (up to
                            HISTORY_LIMIT)</span
                        >
                    </div>
                </div>
            </div>
            <!-- End Main Content -->
        </div>

        <script>
            // ========= CONFIG =========
            let PAGE_SIZE = 10;
            let HISTORY_LIMIT = 12;
            let activeContextPage = 1;
            const settingsExpandedPairs = new Set(); // Track which pairs are expanded in settings view
            const HISTORY_LIMIT_STORAGE_KEY = "chat_clone_history_limit";
            const PAGE_SIZE_STORAGE_KEY = "chat_clone_page_size";
            const CONTEXT_STORAGE_KEY = "chat_clone_context_prompt";
            const CHATNAME_STORAGE_KEY = "chat_clone_chat_name";
            const USER_AVATAR_STORAGE_KEY = "chat_clone_user_avatar";
            const ASSISTANT_AVATAR_OPENAI_KEY = "chat_clone_avatar_openai";
            const ASSISTANT_AVATAR_GOOGLE_KEY = "chat_clone_avatar_google";
            const ASSISTANT_AVATAR_ANTHROPIC_KEY =
                "chat_clone_avatar_anthropic";
            const ASSISTANT_AVATAR_XAI_KEY = "chat_clone_avatar_xai";
            const ASSISTANT_AVATAR_DEEPSEEK_KEY = "chat_clone_avatar_deepseek";
            const ASSISTANT_AVATAR_PERPLEXITY_KEY =
                "chat_clone_avatar_perplexity";
            const ASSISTANT_AVATAR_MISTRAL_KEY = "chat_clone_avatar_mistral";
            const EXPORT_FILENAME_PREFIX = "chat_conversation";
            const CONVO_STORAGE_KEY = "chat_clone_conversation";

            const PROVIDER_STORAGE_KEY = "chat_clone_selected_provider";
            const MODEL_STORAGE_KEY = "chat_clone_selected_model_v2";
            const REASONING_STORAGE_KEY = "chat_clone_reasoning_effort";
            const VERBOSITY_STORAGE_KEY = "chat_clone_verbosity";
            const TEMPERATURE_STORAGE_KEY = "chat_clone_temperature";
            const APIKEY_OPENAI_STORAGE_KEY = "chat_clone_openai_api_key";
            const APIKEY_GOOGLE_STORAGE_KEY = "chat_clone_google_api_key";
            const APIKEY_ANTHROPIC_STORAGE_KEY = "chat_clone_anthropic_api_key";
            const APIKEY_XAI_STORAGE_KEY = "chat_clone_xai_api_key";
            const APIKEY_DEEPSEEK_STORAGE_KEY = "chat_clone_deepseek_api_key";
            const APIKEY_PERPLEXITY_STORAGE_KEY =
                "chat_clone_perplexity_api_key";
            const APIKEY_MISTRAL_STORAGE_KEY = "chat_clone_mistral_api_key";

            const APIKEY_OPENAI_VALID_KEY = "chat_clone_openai_key_valid";
            const APIKEY_GOOGLE_VALID_KEY = "chat_clone_google_key_valid";
            const APIKEY_ANTHROPIC_VALID_KEY = "chat_clone_anthropic_key_valid";
            const APIKEY_XAI_VALID_KEY = "chat_clone_xai_key_valid";
            const APIKEY_DEEPSEEK_VALID_KEY = "chat_clone_deepseek_key_valid";
            const APIKEY_PERPLEXITY_VALID_KEY =
                "chat_clone_perplexity_key_valid";
            const APIKEY_MISTRAL_VALID_KEY = "chat_clone_mistral_key_valid";

            const MODEL_LISTS = {
                openai: [
                    "gpt-5.1",
                    "gpt-5-mini",
                    "gpt-5-nano",
                    "gpt-4.1",
                    "gpt-4.1-mini",
                    "gpt-4.1-nano",
                    "o4-mini",
                    "gpt-5-codex",
                    "gpt-5-codex-mini",
                    "gpt-image-1",
                    "gpt-4o",
                    "gpt-4o-mini",
                ],
                google: [
                    "gemini-3-pro-preview",
                    "gemini-flash-latest",
                    "gemini-flash-lite-latest",
                    "gemini-2.5-flash-image",
                    "gemini-3-pro-image-preview",
                ],
                anthropic: [
                    "claude-opus-4-5-20251101",
                    "claude-sonnet-4-5",
                    "claude-haiku-4-5",
                ],
                xai: ["grok-4-latest"],
                deepseek: [
                    "deepseek-chat",
                    "deepseek-reasoner",
                    "deepseek-coder",
                ],
                perplexity: [
                    "sonar",
                    "sonar-pro",
                    "sonar-reasoning",
                    "sonar-deep-research",
                ],
                mistral: [
                    "codestral-latest",
                    "mistral-large-latest",
                    "mistral-medium-latest",
                    "mistral-small-latest",
                ],
            };

            const PROVIDER_LOGOS = {
                openai: `<svg viewBox="0 0 24 24" fill="currentColor" height="60%" width="60%"><path d="M22.2819 9.8211a5.9847 5.9847 0 0 0-.5157-4.9108 6.0462 6.0462 0 0 0-6.5098-2.9A6.0651 6.0651 0 0 0 4.9807 4.1818a5.9847 5.9847 0 0 0-3.9977 2.9 6.0462 6.0462 0 0 0 .7427 7.0966 5.98 5.98 0 0 0 .511 4.9107 6.0462 6.0462 0 0 0 6.5146 2.9001A5.9847 5.9847 0 0 0 13.2599 24a6.0557 6.0557 0 0 0 5.7718-4.2058 5.9894 5.9894 0 0 0 3.9977-2.9001 6.0557 6.0557 0 0 0-.7475-7.0729zm-9.022 12.6081a4.4755 4.4755 0 0 1-2.8764-1.0408l.1419-.0804 4.7783-2.7582a.7948.7948 0 0 0 .3927-.6813v-6.7369l2.02 1.1686a1.54 1.54 0 0 1 .7218 1.3256v5.5265a4.4607 4.4607 0 0 1-5.1783 3.2769zm4.773-3.2769v-5.5266a1.56 1.56 0 0 1 .0544-.3975l-4.8763-2.8148-.0516.0357-3.9015 2.2519a.777.777 0 0 0-.3926.6813v5.1866a4.466 4.466 0 0 1 1.7082 1.5796 4.4996 4.4996 0 0 1 7.4619-1.0016l.002.0053zm-9.6993-4.1423l4.881-2.8148 4.7783 2.7583a.7948.7948 0 0 0 .7852 0l3.9016-2.2519-1.879-1.0872a1.56 1.56 0 0 1-1.3995-.0843L8.7995 5.9686a4.4578 4.4578 0 0 1 1.8344-1.2825 4.4506 4.4506 0 0 1 2.9696-.062l-.2482.1432-6.5207 3.764c-.4515.2606-.7322.7431-.7322 1.2642v1.2114zM16.636 5.215L11.755 8.03l-.0621.0357-3.9016 2.2519a.7948.7948 0 0 0-.3926.6813v6.7369l-2.02-1.1686a1.54 1.54 0 0 1-.7218-1.3256V9.7151a4.4607 4.4607 0 0 1 5.1783-3.2769l6.8009-1.2232zM8.3323 18.8142l1.9965 1.1543a1.56 1.56 0 0 1 1.3995.0843l4.9048 2.8316c-.9587.6749-2.2036.852-3.3243.4687a4.4549 4.4549 0 0 1-1.4746-.948l.2482-.1432 6.5207-3.764a1.459 1.459 0 0 0 .7322-1.2642v-1.2114l-4.881 2.8148-4.7783-2.7583a.7948.7948 0 0 0-.7852 0l-3.9015 2.2519 3.3429 1.9333z"/></svg>`,
                google: `<svg viewBox="0 0 24 24" fill="currentColor" height="60%" width="60%"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#FFFFFF"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#FFFFFF"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.84z" fill="#FFFFFF"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#FFFFFF"/></svg>`,
                anthropic: `<svg viewBox="0 0 24 24" fill="currentColor" height="65%" width="65%"><path d="M17.85 20.48L15.93 15h-7.85l-1.93 5.48H2.12L10.05 0h3.91l7.93 20.48h-4.04zM12 4.4L8.76 12.65h6.5L12 4.4z"/></svg>`,
                xai: `<svg viewBox="0 0 24 24" fill="currentColor" height="60%" width="60%"><path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg>`,
                deepseek: `<svg viewBox="0 0 24 24" fill="currentColor" height="60%" width="60%"><text x="50%" y="75%" text-anchor="middle" font-size="20" font-weight="bold">D</text></svg>`,
            };

            // ========= STATE =========
            let conversationPairs = [];
            let currentPage = 1;
            let attachedFiles = [];

            // API Keys state
            let apiKeys = {
                openai: "",
                google: "",
                anthropic: "",
                xai: "",
                deepseek: "",
                perplexity: "",
                mistral: "",
            };

            // User avatar state
            let userAvatarDataUrl = null;

            // Assistant provider avatars state
            let assistantAvatars = {
                openai: null,
                google: null,
                anthropic: null,
                xai: null,
                deepseek: null,
            };

            const messagesDiv = document.getElementById("messages");
            const userInput = document.getElementById("user-input");
            const sendBtn = document.getElementById("send-btn");
            const stopBtn = document.getElementById("stop-btn");
            const statusDiv = document.getElementById("status");
            const headerStatusDiv = document.getElementById("header-status");
            const statusDot = document.getElementById("status-dot");
            const statusLogDropdown = document.getElementById(
                "status-log-dropdown",
            );
            const statusLogContent =
                document.getElementById("status-log-content");
            const clearLogBtn = document.getElementById("clear-log-btn");

            // Status log array
            let statusLog = [];

            // AbortController for canceling API requests
            let currentAbortController = null;
            const pageInfoSpan = document.getElementById("page-info");
            const prevPageBtn = document.getElementById("prev-page");
            const nextPageBtn = document.getElementById("next-page");
            const settingsBtn = document.getElementById("settings-btn");
            const settingsView = document.getElementById("settings-view");
            const settingsContextInput = document.getElementById(
                "settings-context-input",
            );
            const historyLimitDisplay = document.getElementById(
                "history-limit-display",
            );
            const historyLimitDec =
                document.getElementById("history-limit-dec");
            const historyLimitInc =
                document.getElementById("history-limit-inc");
            const pageSizeDisplay =
                document.getElementById("page-size-display");
            const pageSizeDec = document.getElementById("page-size-dec");
            const pageSizeInc = document.getElementById("page-size-inc");
            const settingsPinnedList = document.getElementById(
                "settings-pinned-list",
            );
            const settingsActiveList = document.getElementById(
                "settings-active-list",
            );
            const tokenCounter = document.getElementById("token-counter");
            const activePrevPageBtn =
                document.getElementById("active-prev-page");
            const activeNextPageBtn =
                document.getElementById("active-next-page");
            const activePageInfo = document.getElementById("active-page-info");
            const apiKeyBtn = document.getElementById("api-key-btn");
            const apiKeyStatus = document.getElementById("api-key-status");
            const apiKeyModal = document.getElementById("api-key-modal");
            const modalCloseBtn = document.getElementById("modal-close-btn");
            const modalApiKeyInput =
                document.getElementById("modal-apikey-input");
            const modalProviderName = document.getElementById(
                "modal-provider-name",
            );
            const modalToggleVisibility = document.getElementById(
                "modal-toggle-visibility",
            );
            const modalValidationStatus = document.getElementById(
                "modal-validation-status",
            );
            const modalSaveBtn = document.getElementById("modal-save-btn");
            const modalClearBtn = document.getElementById("modal-clear-btn");
            const providerSelect = document.getElementById("provider-select");
            const modelSelect = document.getElementById("model-select");
            const modelSettingsBtn =
                document.getElementById("model-settings-btn");
            const modelSettingsDropdown = document.getElementById(
                "model-settings-dropdown",
            );
            const reasoningSelect = document.getElementById(
                "reasoning-select-new",
            );
            const verbositySelect = document.getElementById(
                "verbosity-select-new",
            );
            const reasoningRow = document.getElementById("reasoning-row");
            const verbosityRow = document.getElementById("verbosity-row");
            const temperatureInput = document.getElementById(
                "temperature-input-new",
            );
            const temperatureRow = document.getElementById("temperature-row");
            const apiLinkBtn = document.getElementById("api-link-btn");
            const newChatBtn = document.getElementById("new-chat-btn");
            const exportBtn = document.getElementById("export-btn");
            const importBtn = document.getElementById("import-btn");
            const importFileInput = document.getElementById("import-file");
            const avatarFileInput =
                document.getElementById("avatar-file-input");
            const attachBtnInput = document.getElementById("attach-btn-input");
            const attachFileInput =
                document.getElementById("attach-file-input");
            const inputAttachmentsList = document.getElementById(
                "input-attachments-list",
            );
            const refreshFilesBtn =
                document.getElementById("refresh-files-btn");
            const refreshDropdown = document.getElementById("refresh-dropdown");

            const backToTopBtn = document.getElementById("back-to-top");

            let attachmentsOpen = false;
            let pendingAssistantNode = null;
            let thinkingIntervalId = null;
            let thinkingTimerIntervalId = null;
            let thinkingStartTime = null;
            let statusTimeoutId = null;
            let attachedFileObjects = []; // Store actual File objects for re-reading
            let lastExportedState = null; // Track last exported conversation state
            let hasUnsavedChangesFlag = false; // Flag to track if there are changes since last export

            // Helper function to update status in header
            // type can be: 'success', 'warning', 'error', or null for default
            function updateStatus(message, type = null) {
                // Clear any existing timeout
                if (statusTimeoutId) {
                    clearTimeout(statusTimeoutId);
                }

                // Remove all state classes
                headerStatusDiv.classList.remove(
                    "show",
                    "fade-out",
                    "success",
                    "warning",
                    "error",
                );

                // Remove dot color classes
                statusDot.classList.remove("warning", "error");

                if (message) {
                    headerStatusDiv.textContent = message;

                    // Add to status log
                    const timestamp = new Date().toLocaleTimeString();
                    statusLog.push({
                        message: message,
                        type: type || "info",
                        timestamp: timestamp,
                    });

                    // Keep only last 50 messages
                    if (statusLog.length > 50) {
                        statusLog.shift();
                    }

                    // Update log display if dropdown is open
                    if (statusLogDropdown.classList.contains("visible")) {
                        renderStatusLog();
                    }

                    // Add type class if specified
                    if (type) {
                        headerStatusDiv.classList.add(type);

                        // Update dot color based on message type
                        if (type === "warning" || type === "error") {
                            statusDot.classList.add(type);
                        }
                    }

                    // Trigger pop-in animation
                    requestAnimationFrame(() => {
                        headerStatusDiv.classList.add("show");
                    });

                    // Auto-clear status after 10 seconds with fade-out
                    statusTimeoutId = setTimeout(() => {
                        headerStatusDiv.classList.add("fade-out");
                        headerStatusDiv.classList.remove("show");

                        // Clear text after fade-out animation completes
                        setTimeout(() => {
                            headerStatusDiv.textContent = "";
                            headerStatusDiv.classList.remove(
                                "fade-out",
                                "success",
                                "warning",
                                "error",
                            );

                            // Reset dot color to green
                            statusDot.classList.remove("warning", "error");
                        }, 300);
                    }, 10000);
                } else {
                    // Clear immediately if empty message
                    headerStatusDiv.textContent = "";

                    // Reset dot color to green
                    statusDot.classList.remove("warning", "error");
                }
            }

            // Function to render status log
            function renderStatusLog() {
                if (statusLog.length === 0) {
                    statusLogContent.innerHTML =
                        '<span style="font-size: 11px; color: var(--text-muted); font-style: italic;">No messages yet</span>';
                    return;
                }

                statusLogContent.innerHTML = "";
                // Show newest first
                for (let i = statusLog.length - 1; i >= 0; i--) {
                    const entry = statusLog[i];
                    const entryDiv = document.createElement("div");
                    entryDiv.className = `status-log-entry ${entry.type}`;
                    entryDiv.innerHTML = `
                        <div class="timestamp">${entry.timestamp}</div>
                        <div>${entry.message}</div>
                    `;
                    statusLogContent.appendChild(entryDiv);
                }
            }

            // ========= IMAGE HANDLING =========
            // Strip images from text for storage (session-only display)
            function stripImages(text) {
                // Replace markdown images: ![alt](url) or ![alt](data:image...)
                let stripped = text.replace(
                    /!\[([^\]]*)\]\(([^)]+)\)/g,
                    (match, alt, url) => {
                        // Check if it's a data URL (base64) or regular URL
                        if (url.startsWith("data:image")) {
                            return `[Image: "${alt}" - not saved (base64 data)]`;
                        } else {
                            return `[Image: "${alt}" - URL expired: ${url}]`;
                        }
                    },
                );

                // Also handle HTML img tags if any
                stripped = stripped.replace(
                    /<img[^>]+src="([^"]*)"[^>]*alt="([^"]*)"[^>]*\/?>/gi,
                    (match, src, alt) => {
                        if (src.startsWith("data:image")) {
                            return `[Image: "${alt}" - not saved (base64 data)]`;
                        } else {
                            return `[Image: "${alt}" - URL expired: ${src}]`;
                        }
                    },
                );

                return stripped;
            }

            // ========= HISTORY LIMIT =========
            function loadHistoryLimit() {
                const stored = localStorage.getItem(HISTORY_LIMIT_STORAGE_KEY);
                let value = parseInt(stored, 10);
                if (Number.isNaN(value) || value < 0 || value > 50) {
                    value = 12;
                }
                HISTORY_LIMIT = value;
            }

            function setHistoryLimit(value) {
                let v = parseInt(value, 10);
                if (Number.isNaN(v)) return;
                if (v < 0) v = 0;
                if (v > 50) v = 50;

                HISTORY_LIMIT = v;
                localStorage.setItem(HISTORY_LIMIT_STORAGE_KEY, String(v));
            }

            // ========= PAGE SIZE =========
            function loadPageSize() {
                const stored = localStorage.getItem(PAGE_SIZE_STORAGE_KEY);
                let value = parseInt(stored, 10);
                if (Number.isNaN(value) || value < 1 || value > 50) {
                    value = 10;
                }
                PAGE_SIZE = value;
            }

            // ========= SETTINGS MODAL =========
            let currentContextPrompt = "";
            let currentChatName = "";

            function loadContextPrompt() {
                const saved = localStorage.getItem(CONTEXT_STORAGE_KEY);
                const defaultPrompt = `You are an AI assistant defined by three core virtues: Radical Honesty, Pragmatic Helpfulness, and Balanced Feedback. Your goal is to be a 'Critical Friend'â€”someone who cares enough to tell the truth but does so to ensure the user's success. Adhere strictly to the following guidelines:

### 1. HONESTY & ACCURACY
- **Fact over Appeasement:** Never confirm a user's misconception to be polite. If the user is mistaken, correct them gently but firmly with evidence.
- **Uncertainty Transparency:** If you do not know an answer or if the premise is ambiguous, state your uncertainty clearly. Do not hallucinate facts or attempt to guess without labeling it as speculation.
- **Intellectual Integrity:** Differentiate clearly between established facts, consensus opinions, and your own analysis.

### 2. BALANCING CRITICISM & CONSTRUCTIVENESS
When reviewing code, writing, or ideas, avoid 'toxic positivity' (blind praise) and 'destructive negativity' (insults). Use the **'Identify-Explain-Solve'** loop:
- **Identify:** Clearly explicitly state what is wrong or suboptimal. Do not sugarcoat errors.
- **Explain:** Briefly explain *why* it is an issue (e.g., creates technical debt, weakens the argument, grammatical error).
- **Solve:** Immediately provide actionable steps, code snippets, or rewrite suggestions to fix the issue.
- **Tone:** Be objective and clinical regarding errors, but encouraging regarding the user's potential to fix them. Use phrases like 'A more effective approach would be...' rather than 'You failed to...'

### 3. HELPFULNESS & UTILITY
- **Action-Oriented:** Avoid vague advice. Provide specific examples, templates, or logic that the user can apply immediately.
- **Relevance:** Do not preach. Keep moralizing to a minimum unless the user's request violates safety guidelines. Focus entirely on the user's stated goal.
- **Conciseness:** Respect the user's time. Be as brief as possible without sacrificing clarity or nuance.

**Instruction Summary:**
If the user's input is flawed, tell them. If the user's input is dangerous, warn them. If the user asks for help, provide the most effective solution, not the easiest one.`;

                currentContextPrompt = saved !== null ? saved : defaultPrompt;
            }

            function loadChatName() {
                const saved = localStorage.getItem(CHATNAME_STORAGE_KEY);
                currentChatName = saved || "";
            }

            function getContextPrompt() {
                return currentContextPrompt.trim();
            }

            function getChatName() {
                return currentChatName;
            }

            // Calculate estimated token count for context
            function updateTokenCounter() {
                let totalChars = 0;

                // Add system prompt
                const systemPrompt = getContextPrompt();
                if (systemPrompt) {
                    totalChars += systemPrompt.length;
                }

                // Add file instructions if any
                const includedFiles = attachedFiles.filter(
                    (f) => f.include !== false,
                );
                if (includedFiles.length > 0) {
                    includedFiles.forEach((f) => {
                        if (f.content) {
                            totalChars += f.content.length;
                        }
                    });
                }

                // Add pinned pairs
                const pinnedPairs = conversationPairs.filter(
                    (p) => p.pinned === true,
                );
                pinnedPairs.forEach((pair) => {
                    totalChars += pair.user.length + pair.assistant.length;
                });

                // Add active context pairs (respecting history limit)
                const includedPairs = conversationPairs.filter(
                    (p) => p.include !== false && p.pinned !== true,
                );
                const recentPairs =
                    HISTORY_LIMIT === 0
                        ? includedPairs
                        : includedPairs.slice(-HISTORY_LIMIT);

                recentPairs.forEach((pair) => {
                    totalChars += pair.user.length + pair.assistant.length;
                });

                // Estimate tokens (roughly 4 characters per token for English)
                const estimatedTokens = Math.ceil(totalChars / 4);

                // Format with commas
                const formattedTokens = estimatedTokens.toLocaleString();

                // Update display with color coding
                tokenCounter.textContent = `~${formattedTokens} tokens`;

                // Color code based on token count (typical limits: 128k, 200k)
                if (estimatedTokens < 50000) {
                    tokenCounter.style.color = "var(--accent)"; // Green
                } else if (estimatedTokens < 100000) {
                    tokenCounter.style.color = "#eab308"; // Yellow
                } else {
                    tokenCounter.style.color = "#ef4444"; // Red
                }
            }

            // Update pinned pairs list in settings view
            function updatePinnedList() {
                const pinnedPairs = conversationPairs.filter(
                    (p) => p.pinned === true,
                );

                settingsPinnedList.innerHTML = "";

                if (pinnedPairs.length === 0) {
                    settingsPinnedList.innerHTML =
                        '<div style="color: var(--text-muted); font-style: italic;">No pinned pairs</div>';
                    return;
                }

                pinnedPairs.forEach((pair) => {
                    const globalIndex = conversationPairs.indexOf(pair);

                    // Check if this pair is expanded in settings view
                    const isCollapsed = !settingsExpandedPairs.has(globalIndex);

                    // ===== COLLAPSED VIEW =====
                    if (isCollapsed) {
                        const row = document.createElement("div");
                        row.className = "message-row collapsed-summary";
                        row.style.marginBottom = "12px";

                        // Add visual indicator for pinned pairs
                        row.style.borderLeft = "3px solid #3b82f6";
                        row.style.paddingLeft = "9px";
                        row.style.background = "rgba(59, 130, 246, 0.05)";

                        const avatarContainer = document.createElement("div");
                        avatarContainer.className = "collapsed-avatars";

                        const userAvatar = document.createElement("div");
                        userAvatar.className = "avatar user";
                        renderUserAvatar(userAvatar);
                        userAvatar.addEventListener("click", () => {
                            avatarFileInput.click();
                        });

                        const assistantAvatar = document.createElement("div");
                        assistantAvatar.className = "avatar assistant";
                        if (pair.provider) {
                            assistantAvatar.classList.add(pair.provider);
                        }

                        // Render avatar (custom or default)
                        renderAssistantAvatar(assistantAvatar, pair.provider);

                        // Make clickable for custom avatar upload
                        assistantAvatar.addEventListener("click", () => {
                            pendingAvatarProvider = pair.provider;
                            avatarFileInput.click();
                        });

                        avatarContainer.appendChild(userAvatar);
                        avatarContainer.appendChild(assistantAvatar);

                        const content = document.createElement("div");
                        content.className = "message-content";

                        const meta = document.createElement("div");
                        meta.className = "message-meta";

                        const metaLeft = document.createElement("div");
                        metaLeft.className = "meta-left";

                        const label = document.createElement("span");
                        label.textContent = "Collapsed pair (Pinned)";

                        metaLeft.appendChild(label);
                        meta.appendChild(metaLeft);

                        // Button container for right side
                        const metaRight = document.createElement("div");
                        metaRight.style.display = "inline-flex";
                        metaRight.style.gap = "6px";

                        // Unpin button (now works when collapsed)
                        const unpinBtn = document.createElement("button");
                        unpinBtn.className = "copy-btn";
                        unpinBtn.textContent = "ðŸ“Œ Unpin";
                        unpinBtn.addEventListener("click", () => {
                            conversationPairs[globalIndex].pinned = false;
                            saveConversationToLocal();
                            updatePinnedList();
                            updateActiveList();
                        });
                        metaRight.appendChild(unpinBtn);

                        // Expand button
                        const expandBtn = document.createElement("button");
                        expandBtn.className = "copy-btn";
                        expandBtn.textContent = "Expand pair";
                        expandBtn.addEventListener("click", () => {
                            settingsExpandedPairs.add(globalIndex);
                            updatePinnedList();
                            updateActiveList();
                        });
                        metaRight.appendChild(expandBtn);

                        meta.appendChild(metaRight);

                        const bubble = document.createElement("div");
                        bubble.className = "collapsed-summary-bubble";

                        const userPreview = (pair.user || "").slice(0, 80);
                        bubble.textContent =
                            (userPreview || "(empty prompt)") +
                            (pair.user && pair.user.length > 80 ? "â€¦" : "");

                        content.appendChild(meta);
                        content.appendChild(bubble);

                        row.appendChild(avatarContainer);
                        row.appendChild(content);
                        settingsPinnedList.appendChild(row);
                        return;
                    }

                    // ===== EXPANDED VIEW =====
                    // Container for the pair
                    const pairContainer = document.createElement("div");
                    pairContainer.style.marginBottom = "12px";

                    // ===== USER ROW =====
                    const userRow = document.createElement("div");
                    userRow.className = "message-row";
                    userRow.style.borderLeft = "3px solid #3b82f6";
                    userRow.style.paddingLeft = "9px";
                    userRow.style.background = "rgba(59, 130, 246, 0.05)";

                    const userAvatar = document.createElement("div");
                    userAvatar.className = "avatar user";
                    renderUserAvatar(userAvatar);
                    userAvatar.addEventListener("click", () => {
                        avatarFileInput.click();
                    });

                    const userContent = document.createElement("div");
                    userContent.className = "message-content";

                    const userMeta = document.createElement("div");
                    userMeta.className = "message-meta";

                    const metaLeft = document.createElement("div");
                    metaLeft.className = "meta-left";

                    const youLabel = document.createElement("span");
                    youLabel.textContent = "You (Pinned)";

                    metaLeft.appendChild(youLabel);
                    userMeta.appendChild(metaLeft);

                    // Add action buttons to user meta
                    const metaRight = document.createElement("div");
                    metaRight.style.display = "inline-flex";
                    metaRight.style.gap = "6px";

                    // Unpin button
                    const unpinBtn = document.createElement("button");
                    unpinBtn.className = "copy-btn";
                    unpinBtn.textContent = "ðŸ“Œ Unpin";
                    unpinBtn.addEventListener("click", () => {
                        conversationPairs[globalIndex].pinned = false;
                        saveConversationToLocal();
                        updatePinnedList();
                        updateActiveList();
                    });
                    metaRight.appendChild(unpinBtn);

                    // Collapse pair button
                    const collapsePairBtn = document.createElement("button");
                    collapsePairBtn.className = "copy-btn";
                    collapsePairBtn.textContent = "Collapse pair";
                    collapsePairBtn.addEventListener("click", () => {
                        settingsExpandedPairs.delete(globalIndex);
                        updatePinnedList();
                        updateActiveList();
                    });
                    metaRight.appendChild(collapsePairBtn);

                    userMeta.appendChild(metaRight);

                    const userBubble = document.createElement("div");
                    userBubble.className = "message-bubble user";
                    userBubble.textContent = pair.user;

                    userContent.appendChild(userMeta);
                    userContent.appendChild(userBubble);
                    userRow.appendChild(userAvatar);
                    userRow.appendChild(userContent);

                    pairContainer.appendChild(userRow);

                    // ===== ASSISTANT ROW =====
                    const assistantRow = document.createElement("div");
                    assistantRow.className = "message-row assistant";
                    assistantRow.style.borderLeft = "3px solid #3b82f6";
                    assistantRow.style.paddingLeft = "9px";
                    assistantRow.style.background = "rgba(59, 130, 246, 0.05)";

                    const assistantAvatar = document.createElement("div");
                    assistantAvatar.className = "avatar assistant";
                    if (pair.provider) {
                        assistantAvatar.classList.add(pair.provider);
                    }

                    // Render avatar (custom or default)
                    renderAssistantAvatar(assistantAvatar, pair.provider);

                    // Make clickable for custom avatar upload
                    assistantAvatar.addEventListener("click", () => {
                        pendingAvatarProvider = pair.provider;
                        avatarFileInput.click();
                    });

                    const assistantContent = document.createElement("div");
                    assistantContent.className = "message-content";

                    const assistantMeta = document.createElement("div");
                    assistantMeta.className = "message-meta";

                    const metaLeftA = document.createElement("div");
                    metaLeftA.className = "meta-left";

                    const assistantLabel = document.createElement("span");
                    assistantLabel.textContent = "Assistant";

                    metaLeftA.appendChild(assistantLabel);

                    // Add elapsed time if available
                    if (
                        pair.elapsedMs !== null &&
                        pair.elapsedMs !== undefined
                    ) {
                        const elapsedSpan = document.createElement("span");
                        elapsedSpan.className = "thinking-timer";
                        const seconds = Math.floor(pair.elapsedMs / 1000);
                        const ms = Math.floor((pair.elapsedMs % 1000) / 10);
                        elapsedSpan.textContent = `(${seconds}.${ms.toString().padStart(2, "0")}s)`;
                        metaLeftA.appendChild(elapsedSpan);
                    }

                    assistantMeta.appendChild(metaLeftA);

                    const assistantBubble = document.createElement("div");
                    assistantBubble.className = "message-bubble assistant";
                    assistantBubble.innerHTML = marked.parse(pair.assistant);

                    assistantContent.appendChild(assistantMeta);
                    assistantContent.appendChild(assistantBubble);
                    assistantRow.appendChild(assistantAvatar);
                    assistantRow.appendChild(assistantContent);

                    pairContainer.appendChild(assistantRow);
                    settingsPinnedList.appendChild(pairContainer);
                });

                // Enhance code blocks in pinned list
                const codeBlocks =
                    settingsPinnedList.querySelectorAll("pre code");
                codeBlocks.forEach((block) => {
                    hljs.highlightElement(block);
                });

                // Update token counter
                updateTokenCounter();
            }

            // Update active context pairs list in settings view
            function updateActiveList() {
                // Get regular included pairs (excluding pinned ones)
                const recentPairs = conversationPairs.filter(
                    (p) => p.include !== false && p.pinned !== true,
                );

                // Apply HISTORY_LIMIT
                const limitedPairs =
                    HISTORY_LIMIT === 0
                        ? recentPairs
                        : recentPairs.slice(-HISTORY_LIMIT);

                settingsActiveList.innerHTML = "";

                if (limitedPairs.length === 0) {
                    settingsActiveList.innerHTML =
                        '<div style="color: var(--text-muted); font-style: italic;">No active context pairs</div>';
                    activePageInfo.textContent = "";
                    activePrevPageBtn.disabled = true;
                    activeNextPageBtn.disabled = true;
                    return;
                }

                // Calculate pagination
                const totalPairs = limitedPairs.length;
                let pagePairs;

                if (PAGE_SIZE === 0) {
                    // PAGE_SIZE = 0 means unlimited, show all pairs
                    pagePairs = limitedPairs;
                    activePageInfo.textContent = "All pairs";
                    activePrevPageBtn.disabled = true;
                    activeNextPageBtn.disabled = true;
                } else {
                    const totalPages = Math.ceil(totalPairs / PAGE_SIZE);
                    if (activeContextPage > totalPages)
                        activeContextPage = totalPages;
                    if (activeContextPage < 1) activeContextPage = 1;

                    // Get pairs for current page (from end, like main chat view)
                    const startIndex = Math.max(
                        0,
                        totalPairs - activeContextPage * PAGE_SIZE,
                    );
                    const endIndex = Math.min(
                        totalPairs,
                        startIndex + PAGE_SIZE,
                    );
                    pagePairs = limitedPairs.slice(startIndex, endIndex);

                    // Update page info
                    activePageInfo.textContent = `Page ${activeContextPage} / ${totalPages}`;
                    activePrevPageBtn.disabled =
                        activeContextPage >= totalPages;
                    activeNextPageBtn.disabled = activeContextPage <= 1;
                }

                // Display summary info
                const summaryDiv = document.createElement("div");
                summaryDiv.style.marginBottom = "8px";
                summaryDiv.style.fontSize = "12px";
                summaryDiv.style.color = "var(--text-muted)";
                summaryDiv.innerHTML = `<strong>${totalPairs} pair(s)</strong> in active context (limit: ${HISTORY_LIMIT === 0 ? "âˆž" : HISTORY_LIMIT})`;
                settingsActiveList.appendChild(summaryDiv);

                pagePairs.forEach((pair) => {
                    const globalIndex = conversationPairs.indexOf(pair);
                    // Check if this pair is expanded in settings view
                    const isCollapsed = !settingsExpandedPairs.has(globalIndex);

                    if (isCollapsed) {
                        // ===== COLLAPSED VIEW =====
                        const row = document.createElement("div");
                        row.className = "message-row collapsed-summary";
                        row.style.marginBottom = "12px";
                        row.style.borderLeft = "3px solid #10b981";
                        row.style.background = "rgba(16, 185, 129, 0.05)";
                        row.style.paddingLeft = "9px";

                        const avatarContainer = document.createElement("div");
                        avatarContainer.className = "collapsed-avatars";

                        const userAvatar = document.createElement("div");
                        userAvatar.className = "avatar user";
                        renderUserAvatar(userAvatar);
                        userAvatar.addEventListener("click", () => {
                            avatarFileInput.click();
                        });

                        const assistantAvatar = document.createElement("div");
                        assistantAvatar.className = "avatar assistant";
                        if (pair.provider) {
                            assistantAvatar.classList.add(pair.provider);
                        }
                        renderAssistantAvatar(assistantAvatar, pair.provider);
                        assistantAvatar.addEventListener("click", () => {
                            pendingAvatarProvider = pair.provider;
                            avatarFileInput.click();
                        });

                        avatarContainer.appendChild(userAvatar);
                        avatarContainer.appendChild(assistantAvatar);

                        const content = document.createElement("div");
                        content.className = "message-content";

                        const meta = document.createElement("div");
                        meta.className = "message-meta";

                        const metaLeft = document.createElement("div");
                        metaLeft.className = "meta-left";

                        const label = document.createElement("span");
                        label.textContent = `Pair #${globalIndex + 1}`;
                        metaLeft.appendChild(label);
                        meta.appendChild(metaLeft);

                        // Button container for right side
                        const metaRight = document.createElement("div");
                        metaRight.style.display = "inline-flex";
                        metaRight.style.gap = "6px";

                        // Exclude button
                        const excludeBtn = document.createElement("button");
                        excludeBtn.className = "copy-btn";
                        excludeBtn.textContent = "ðŸš« Exclude";
                        excludeBtn.addEventListener("click", () => {
                            conversationPairs[globalIndex].include = false;
                            saveConversationToLocal();
                            updateActiveList();
                        });
                        metaRight.appendChild(excludeBtn);

                        // Expand button
                        const expandBtn = document.createElement("button");
                        expandBtn.className = "copy-btn";
                        expandBtn.textContent = "Expand pair";
                        expandBtn.addEventListener("click", () => {
                            settingsExpandedPairs.add(globalIndex);
                            updateActiveList();
                        });
                        metaRight.appendChild(expandBtn);

                        meta.appendChild(metaRight);

                        const bubble = document.createElement("div");
                        bubble.className = "collapsed-summary-bubble";

                        const userPreview = (pair.user || "").slice(0, 80);
                        bubble.textContent =
                            (userPreview || "(empty prompt)") +
                            (pair.user && pair.user.length > 80 ? "â€¦" : "");

                        content.appendChild(meta);
                        content.appendChild(bubble);

                        row.appendChild(avatarContainer);
                        row.appendChild(content);
                        settingsActiveList.appendChild(row);
                    } else {
                        // ===== EXPANDED VIEW =====
                        const pairContainer = document.createElement("div");
                        pairContainer.style.marginBottom = "12px";

                        // ===== USER ROW =====
                        const userRow = document.createElement("div");
                        userRow.className = "message-row";
                        userRow.style.borderLeft = "3px solid #10b981";
                        userRow.style.paddingLeft = "9px";
                        userRow.style.background = "rgba(16, 185, 129, 0.05)";

                        const userAvatar = document.createElement("div");
                        userAvatar.className = "avatar user";
                        renderUserAvatar(userAvatar);
                        userAvatar.addEventListener("click", () => {
                            avatarFileInput.click();
                        });

                        const userContent = document.createElement("div");
                        userContent.className = "message-content";

                        const userMeta = document.createElement("div");
                        userMeta.className = "message-meta";

                        const metaLeft = document.createElement("div");
                        metaLeft.className = "meta-left";

                        const youLabel = document.createElement("span");
                        youLabel.textContent = `You (Pair #${globalIndex + 1})`;
                        metaLeft.appendChild(youLabel);
                        userMeta.appendChild(metaLeft);

                        // Add action buttons
                        const metaRight = document.createElement("div");
                        metaRight.style.display = "inline-flex";
                        metaRight.style.gap = "6px";

                        // Exclude button
                        const excludeBtn = document.createElement("button");
                        excludeBtn.className = "copy-btn";
                        excludeBtn.textContent = "ðŸš« Exclude";
                        excludeBtn.addEventListener("click", () => {
                            conversationPairs[globalIndex].include = false;
                            saveConversationToLocal();
                            updateActiveList();
                        });
                        metaRight.appendChild(excludeBtn);

                        // Collapse pair button
                        const collapsePairBtn =
                            document.createElement("button");
                        collapsePairBtn.className = "copy-btn";
                        collapsePairBtn.textContent = "Collapse pair";
                        collapsePairBtn.addEventListener("click", () => {
                            settingsExpandedPairs.delete(globalIndex);
                            updateActiveList();
                        });
                        metaRight.appendChild(collapsePairBtn);

                        userMeta.appendChild(metaRight);

                        const userBubble = document.createElement("div");
                        userBubble.className = "message-bubble user";
                        userBubble.textContent = pair.user;

                        userContent.appendChild(userMeta);
                        userContent.appendChild(userBubble);
                        userRow.appendChild(userAvatar);
                        userRow.appendChild(userContent);

                        pairContainer.appendChild(userRow);

                        // ===== ASSISTANT ROW =====
                        const assistantRow = document.createElement("div");
                        assistantRow.className = "message-row assistant";
                        assistantRow.style.borderLeft = "3px solid #10b981";
                        assistantRow.style.paddingLeft = "9px";
                        assistantRow.style.background =
                            "rgba(16, 185, 129, 0.05)";

                        const assistantAvatar = document.createElement("div");
                        assistantAvatar.className = "avatar assistant";
                        if (pair.provider) {
                            assistantAvatar.classList.add(pair.provider);
                        }
                        renderAssistantAvatar(assistantAvatar, pair.provider);
                        assistantAvatar.addEventListener("click", () => {
                            pendingAvatarProvider = pair.provider;
                            avatarFileInput.click();
                        });

                        const assistantContent = document.createElement("div");
                        assistantContent.className = "message-content";

                        const assistantMeta = document.createElement("div");
                        assistantMeta.className = "message-meta";

                        const metaLeftA = document.createElement("div");
                        metaLeftA.className = "meta-left";

                        const assistantLabel = document.createElement("span");
                        assistantLabel.textContent = "Assistant";
                        metaLeftA.appendChild(assistantLabel);

                        // Add elapsed time if available
                        if (
                            pair.elapsedMs !== null &&
                            pair.elapsedMs !== undefined
                        ) {
                            const elapsedSpan = document.createElement("span");
                            elapsedSpan.className = "thinking-timer";
                            const seconds = Math.floor(pair.elapsedMs / 1000);
                            const ms = Math.floor((pair.elapsedMs % 1000) / 10);
                            elapsedSpan.textContent = `(${seconds}.${ms.toString().padStart(2, "0")}s)`;
                            metaLeftA.appendChild(elapsedSpan);
                        }

                        assistantMeta.appendChild(metaLeftA);

                        const assistantBubble = document.createElement("div");
                        assistantBubble.className = "message-bubble assistant";
                        assistantBubble.innerHTML = marked.parse(
                            pair.assistant,
                        );

                        assistantContent.appendChild(assistantMeta);
                        assistantContent.appendChild(assistantBubble);
                        assistantRow.appendChild(assistantAvatar);
                        assistantRow.appendChild(assistantContent);

                        pairContainer.appendChild(assistantRow);
                        settingsActiveList.appendChild(pairContainer);
                    }
                });

                // Enhance code blocks in active list
                const codeBlocks =
                    settingsActiveList.querySelectorAll("pre code");
                codeBlocks.forEach((block) => {
                    hljs.highlightElement(block);
                });

                // Update token counter
                updateTokenCounter();
            }

            // Active context pagination
            activePrevPageBtn.addEventListener("click", () => {
                activeContextPage++;
                updateActiveList();
            });

            activeNextPageBtn.addEventListener("click", () => {
                activeContextPage--;
                updateActiveList();
            });

            // Toggle settings view
            settingsBtn.addEventListener("click", () => {
                const isSettingsVisible =
                    settingsView.classList.contains("visible");
                if (isSettingsVisible) {
                    // Switch back to chat view
                    settingsView.classList.remove("visible");
                    messagesDiv.style.display = "block";
                    settingsBtn.classList.remove("active");
                } else {
                    // Switch to settings view
                    settingsContextInput.value = currentContextPrompt;
                    activeContextPage = 1; // Reset to page 1 when opening settings
                    updatePinnedList();
                    updateActiveList();
                    messagesDiv.style.display = "none";
                    settingsView.classList.add("visible");
                    settingsBtn.classList.add("active");
                }
            });

            // Close settings button
            // Auto-save context prompt
            settingsContextInput.addEventListener("input", () => {
                currentContextPrompt = settingsContextInput.value;
                localStorage.setItem(CONTEXT_STORAGE_KEY, currentContextPrompt);
                updateTokenCounter();
            });

            // Handle history limit changes with +/- buttons
            function updateHistoryLimitDisplay() {
                historyLimitDisplay.value = HISTORY_LIMIT;
            }

            // Handle direct input for history limit
            historyLimitDisplay.addEventListener("input", () => {
                const value = parseInt(historyLimitDisplay.value, 10);
                if (!isNaN(value) && value >= 0 && value <= 50) {
                    setHistoryLimit(value);
                    updateActiveList();
                    const limitText =
                        value === 0 ? "unlimited" : `${value} pair(s)`;
                    updateStatus(
                        `Context history limit set to ${limitText}.`,
                        "success",
                    );
                }
            });

            historyLimitDec.addEventListener("click", () => {
                if (HISTORY_LIMIT > 0) {
                    setHistoryLimit(HISTORY_LIMIT - 1);
                    updateHistoryLimitDisplay();
                    updateActiveList();
                    const limitText =
                        HISTORY_LIMIT === 0
                            ? "unlimited"
                            : `${HISTORY_LIMIT} pair(s)`;
                    updateStatus(
                        `Context history limit set to ${limitText}.`,
                        "success",
                    );
                }
            });

            historyLimitInc.addEventListener("click", () => {
                if (HISTORY_LIMIT < 50) {
                    setHistoryLimit(HISTORY_LIMIT + 1);
                    updateHistoryLimitDisplay();
                    updateActiveList();
                    updateStatus(
                        `Context history limit set to ${HISTORY_LIMIT} pair(s).`,
                        "success",
                    );
                }
            });

            // Handle page size changes with +/- buttons
            function updatePageSizeDisplay() {
                pageSizeDisplay.value = PAGE_SIZE;
            }

            // Handle direct input for page size
            pageSizeDisplay.addEventListener("input", () => {
                const value = parseInt(pageSizeDisplay.value, 10);
                if (!isNaN(value) && value >= 0 && value <= 100) {
                    PAGE_SIZE = value;
                    localStorage.setItem(
                        PAGE_SIZE_STORAGE_KEY,
                        String(PAGE_SIZE),
                    );
                    currentPage = 1;
                    renderPage();
                    const sizeText =
                        value === 0 ? "unlimited" : `${value} pair(s)`;
                    updateStatus(`Page size set to ${sizeText}.`, "success");
                }
            });

            pageSizeDec.addEventListener("click", () => {
                if (PAGE_SIZE > 1) {
                    PAGE_SIZE--;
                    localStorage.setItem(
                        PAGE_SIZE_STORAGE_KEY,
                        String(PAGE_SIZE),
                    );
                    updatePageSizeDisplay();
                    currentPage = 1;
                    renderPage();
                    updateStatus(
                        `Page size set to ${PAGE_SIZE} pair(s).`,
                        "success",
                    );
                }
            });

            pageSizeInc.addEventListener("click", () => {
                if (PAGE_SIZE < 50) {
                    PAGE_SIZE++;
                    localStorage.setItem(
                        PAGE_SIZE_STORAGE_KEY,
                        String(PAGE_SIZE),
                    );
                    updatePageSizeDisplay();
                    currentPage = 1;
                    renderPage();
                    updateStatus(
                        `Page size set to ${PAGE_SIZE} pair(s).`,
                        "success",
                    );
                }
            });

            // Handle chat name field
            // ========= API KEY & PROVIDER LOGIC =========
            function loadApiKeys() {
                const oaKey = localStorage.getItem(APIKEY_OPENAI_STORAGE_KEY);
                const gKey = localStorage.getItem(APIKEY_GOOGLE_STORAGE_KEY);
                const aKey = localStorage.getItem(APIKEY_ANTHROPIC_STORAGE_KEY);
                const xKey = localStorage.getItem(APIKEY_XAI_STORAGE_KEY);
                const dKey = localStorage.getItem(APIKEY_DEEPSEEK_STORAGE_KEY);
                const pKey = localStorage.getItem(
                    APIKEY_PERPLEXITY_STORAGE_KEY,
                );
                const mKey = localStorage.getItem(APIKEY_MISTRAL_STORAGE_KEY);
                if (oaKey) apiKeys.openai = oaKey;
                if (gKey) apiKeys.google = gKey;
                if (aKey) apiKeys.anthropic = aKey;
                if (xKey) apiKeys.xai = xKey;
                if (dKey) apiKeys.deepseek = dKey;
                if (pKey) apiKeys.perplexity = pKey;
                if (mKey) apiKeys.mistral = mKey;
            }

            function loadProviderAndModel() {
                // Load Provider
                const savedProvider =
                    localStorage.getItem(PROVIDER_STORAGE_KEY);
                if (
                    savedProvider &&
                    (savedProvider === "openai" ||
                        savedProvider === "google" ||
                        savedProvider === "anthropic" ||
                        savedProvider === "xai" ||
                        savedProvider === "deepseek")
                ) {
                    providerSelect.value = savedProvider;
                } else {
                    providerSelect.value = "openai";
                }

                updateModelOptions(); // Populate models based on provider

                // Load Model
                const savedModel = localStorage.getItem(MODEL_STORAGE_KEY);
                if (savedModel) {
                    // Verify if it exists in current list
                    const options = Array.from(modelSelect.options).map(
                        (o) => o.value,
                    );
                    if (options.includes(savedModel)) {
                        modelSelect.value = savedModel;
                    }
                }

                // Load reasoning effort (OpenAI only)
                const savedReasoning = localStorage.getItem(
                    REASONING_STORAGE_KEY,
                );
                if (
                    savedReasoning &&
                    ["none", "low", "medium", "high"].includes(savedReasoning)
                ) {
                    reasoningSelect.value = savedReasoning;
                } else {
                    reasoningSelect.value = "none";
                }

                // Load verbosity (OpenAI only)
                const savedVerbosity = localStorage.getItem(
                    VERBOSITY_STORAGE_KEY,
                );
                if (
                    savedVerbosity &&
                    ["low", "medium", "high"].includes(savedVerbosity)
                ) {
                    verbositySelect.value = savedVerbosity;
                } else {
                    verbositySelect.value = "medium";
                }

                // Load temperature (for Claude, Gemini, xAI, GPT-4)
                const savedTemperature = localStorage.getItem(
                    TEMPERATURE_STORAGE_KEY,
                );
                if (savedTemperature) {
                    const temp = parseFloat(savedTemperature);
                    if (!isNaN(temp) && temp >= 0 && temp <= 2) {
                        temperatureInput.value = temp;
                    }
                } else {
                    temperatureInput.value = 1.0;
                }

                updateApiLink(); // Update API credits link for this provider
                updateOpenAIControls(); // Show/hide OpenAI-specific controls
            }

            function updateModelOptions() {
                const provider = providerSelect.value;
                const models = MODEL_LISTS[provider] || [];

                modelSelect.innerHTML = "";
                models.forEach((m) => {
                    const opt = document.createElement("option");
                    opt.value = m;
                    opt.textContent = m;
                    modelSelect.appendChild(opt);
                });
            }

            function updateApiLink() {
                const provider = providerSelect.value;
                const apiLinks = {
                    openai: "https://platform.openai.com/usage",
                    google: "https://aistudio.google.com/u/1/usage?pli=1&timeRange=last-28-days&project=gen-lang-client-0347389595&tab=billing",
                    anthropic: "https://console.anthropic.com/settings/billing",
                    xai: "https://console.x.ai/",
                    deepseek: "https://platform.deepseek.com/usage",
                    perplexity: "https://www.perplexity.ai/settings/api",
                    mistral: "https://console.mistral.ai/",
                };
                apiLinkBtn.href = apiLinks[provider] || "#";
            }

            function updateOpenAIControls() {
                const provider = providerSelect.value;
                const model = modelSelect.value;
                const isOpenAI = provider === "openai";

                // Check if it's a GPT-5 model (which uses reasoning/verbosity, not temperature)
                const isGPT5 = model && model.includes("gpt-5");
                const isImageModel =
                    model &&
                    (model === "gpt-image-1" ||
                        model === "gemini-2.5-flash-image" ||
                        model === "gemini-3-pro-image-preview");

                // Show/hide reasoning and verbosity controls for OpenAI (only GPT-5 models, not image models)
                reasoningRow.style.display =
                    isOpenAI && isGPT5 && !isImageModel ? "flex" : "none";
                verbosityRow.style.display =
                    isOpenAI && isGPT5 && !isImageModel ? "flex" : "none";

                // Show temperature for Claude, Gemini, xAI, DeepSeek, and GPT-4 (but not GPT-5 or image models)
                const showTemperature =
                    !isImageModel &&
                    (provider === "anthropic" ||
                        provider === "google" ||
                        provider === "xai" ||
                        provider === "deepseek" ||
                        provider === "perplexity" ||
                        provider === "mistral" ||
                        (isOpenAI && !isGPT5));
                temperatureRow.style.display = showTemperature
                    ? "flex"
                    : "none";

                // Set temperature limits based on provider
                if (provider === "anthropic") {
                    // Anthropic: 0-1
                    temperatureInput.max = "1";
                    temperatureInput.step = "0.1";
                    if (parseFloat(temperatureInput.value) > 1) {
                        temperatureInput.value = "1.0";
                    }
                } else {
                    // OpenAI, Google, xAI: 0-2
                    temperatureInput.max = "2";
                    temperatureInput.step = "0.1";
                }

                // Show/hide the settings button based on whether any settings are available
                const hasSettings = (isOpenAI && isGPT5) || showTemperature;
                modelSettingsBtn.style.display = hasSettings
                    ? "inline-flex"
                    : "none";
            }

            // Toggle model settings dropdown
            modelSettingsBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                const isVisible =
                    modelSettingsDropdown.classList.contains("visible");
                if (isVisible) {
                    modelSettingsDropdown.classList.remove("visible");
                    modelSettingsBtn.classList.remove("active");
                } else {
                    modelSettingsDropdown.classList.add("visible");
                    modelSettingsBtn.classList.add("active");
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener("click", (e) => {
                if (
                    !modelSettingsBtn.contains(e.target) &&
                    !modelSettingsDropdown.contains(e.target)
                ) {
                    modelSettingsDropdown.classList.remove("visible");
                    modelSettingsBtn.classList.remove("active");
                }
            });

            providerSelect.addEventListener("change", (e) => {
                const newProvider = e.target.value;
                localStorage.setItem(PROVIDER_STORAGE_KEY, newProvider);
                updateModelOptions();
                updateApiKeyStatus();
                updateApiLink();
                updateOpenAIControls();
                // Select first model by default on provider switch
                if (modelSelect.options.length > 0) {
                    modelSelect.selectedIndex = 0;
                    localStorage.setItem(MODEL_STORAGE_KEY, modelSelect.value);
                }
            });

            modelSelect.addEventListener("change", (e) => {
                localStorage.setItem(MODEL_STORAGE_KEY, e.target.value);
                updateOpenAIControls(); // Update visibility when model changes
            });

            reasoningSelect.addEventListener("change", (e) => {
                localStorage.setItem(REASONING_STORAGE_KEY, e.target.value);
            });

            verbositySelect.addEventListener("change", (e) => {
                localStorage.setItem(VERBOSITY_STORAGE_KEY, e.target.value);
            });

            temperatureInput.addEventListener("input", (e) => {
                const temp = parseFloat(e.target.value);
                if (!isNaN(temp) && temp >= 0 && temp <= 2) {
                    localStorage.setItem(
                        TEMPERATURE_STORAGE_KEY,
                        temp.toString(),
                    );
                }
            });

            function getApiKey() {
                const provider = providerSelect.value;
                return apiKeys[provider];
            }

            // ========= USER AVATAR =========
            function loadUserAvatar() {
                const stored = localStorage.getItem(USER_AVATAR_STORAGE_KEY);
                if (stored) {
                    userAvatarDataUrl = stored;
                }
            }

            function saveUserAvatar(dataUrl) {
                userAvatarDataUrl = dataUrl;
                localStorage.setItem(USER_AVATAR_STORAGE_KEY, dataUrl);
                updateStatus("Profile picture updated", "success");
            }

            function clearUserAvatar() {
                userAvatarDataUrl = null;
                localStorage.removeItem(USER_AVATAR_STORAGE_KEY);
            }

            function renderUserAvatar(avatarElement) {
                if (userAvatarDataUrl) {
                    avatarElement.textContent = "";
                    const img = document.createElement("img");
                    img.src = userAvatarDataUrl;
                    img.alt = "User avatar";
                    avatarElement.appendChild(img);
                } else {
                    avatarElement.textContent = "P";
                }
            }

            // Handle avatar file selection
            let pendingAvatarProvider = null; // Track which provider avatar is being uploaded

            avatarFileInput.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Validate file type
                if (!file.type.startsWith("image/")) {
                    updateStatus("Please select an image file", "error");
                    return;
                }

                // Validate file size (max 2MB)
                if (file.size > 2 * 1024 * 1024) {
                    updateStatus("Image must be smaller than 2MB", "error");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    const dataUrl = event.target.result;

                    // Check if this is for a provider avatar or user avatar
                    if (pendingAvatarProvider) {
                        saveAssistantAvatar(pendingAvatarProvider, dataUrl);
                        pendingAvatarProvider = null;
                    } else {
                        saveUserAvatar(dataUrl);
                    }

                    // Re-render the page to update all avatars
                    renderPage();
                };
                reader.onerror = () => {
                    updateStatus("Failed to load image", "error");
                    pendingAvatarProvider = null;
                };
                reader.readAsDataURL(file);

                // Clear the input so the same file can be selected again
                e.target.value = "";
            });

            // ========= ASSISTANT AVATARS =========
            function loadAssistantAvatars() {
                const storageKeys = {
                    openai: ASSISTANT_AVATAR_OPENAI_KEY,
                    google: ASSISTANT_AVATAR_GOOGLE_KEY,
                    anthropic: ASSISTANT_AVATAR_ANTHROPIC_KEY,
                    xai: ASSISTANT_AVATAR_XAI_KEY,
                    deepseek: ASSISTANT_AVATAR_DEEPSEEK_KEY,
                    perplexity: ASSISTANT_AVATAR_PERPLEXITY_KEY,
                    mistral: ASSISTANT_AVATAR_MISTRAL_KEY,
                };

                for (const provider in storageKeys) {
                    const stored = localStorage.getItem(storageKeys[provider]);
                    if (stored) {
                        assistantAvatars[provider] = stored;
                    }
                }
            }

            function saveAssistantAvatar(provider, dataUrl) {
                assistantAvatars[provider] = dataUrl;
                const storageKeys = {
                    openai: ASSISTANT_AVATAR_OPENAI_KEY,
                    google: ASSISTANT_AVATAR_GOOGLE_KEY,
                    anthropic: ASSISTANT_AVATAR_ANTHROPIC_KEY,
                    xai: ASSISTANT_AVATAR_XAI_KEY,
                    deepseek: ASSISTANT_AVATAR_DEEPSEEK_KEY,
                    perplexity: ASSISTANT_AVATAR_PERPLEXITY_KEY,
                    mistral: ASSISTANT_AVATAR_MISTRAL_KEY,
                };
                localStorage.setItem(storageKeys[provider], dataUrl);

                const providerNames = {
                    openai: "OpenAI",
                    google: "Google",
                    anthropic: "Anthropic",
                    xai: "xAI",
                    deepseek: "DeepSeek",
                    perplexity: "Perplexity",
                    mistral: "Mistral",
                };
                updateStatus(
                    `${providerNames[provider]} avatar updated`,
                    "success",
                );
            }

            function renderAssistantAvatar(avatarElement, provider) {
                const customAvatar = assistantAvatars[provider];

                if (customAvatar) {
                    // Clear existing content and show custom image
                    avatarElement.innerHTML = "";
                    const img = document.createElement("img");
                    img.src = customAvatar;
                    img.alt = `${provider} avatar`;
                    avatarElement.appendChild(img);
                } else {
                    // Use default logo or fallback
                    if (provider && PROVIDER_LOGOS[provider]) {
                        avatarElement.innerHTML = PROVIDER_LOGOS[provider];
                    } else {
                        avatarElement.textContent = "R";
                    }
                }
            }

            // ========= API KEY MODAL =========
            function updateApiKeyStatus() {
                const provider = providerSelect.value;
                const key = apiKeys[provider];

                apiKeyStatus.classList.remove("no-key", "has-key", "valid-key");

                if (!key) {
                    apiKeyStatus.classList.add("no-key");
                    apiKeyStatus.title = "No API key set";
                } else {
                    // Check if we have stored validation status
                    const validationKeys = {
                        openai: APIKEY_OPENAI_VALID_KEY,
                        google: APIKEY_GOOGLE_VALID_KEY,
                        anthropic: APIKEY_ANTHROPIC_VALID_KEY,
                        xai: APIKEY_XAI_VALID_KEY,
                        deepseek: APIKEY_DEEPSEEK_VALID_KEY,
                        perplexity: APIKEY_PERPLEXITY_VALID_KEY,
                        mistral: APIKEY_MISTRAL_VALID_KEY,
                    };

                    const isValid =
                        localStorage.getItem(validationKeys[provider]) ===
                        "true";

                    if (isValid) {
                        apiKeyStatus.classList.add("valid-key");
                        apiKeyStatus.title = "Valid API key";
                    } else {
                        apiKeyStatus.classList.add("has-key");
                        apiKeyStatus.title = "API key set (click to manage)";
                    }
                }
            }

            function openApiKeyModal() {
                const provider = providerSelect.value;
                const providerNames = {
                    openai: "OpenAI",
                    google: "Google",
                    anthropic: "Anthropic",
                    xai: "xAI",
                    deepseek: "DeepSeek",
                    perplexity: "Perplexity",
                    mistral: "Mistral",
                };

                modalProviderName.textContent =
                    providerNames[provider] || provider;
                modalApiKeyInput.value = apiKeys[provider] || "";
                modalApiKeyInput.type = "password";
                modalValidationStatus.textContent = "";
                modalValidationStatus.className = "modal-validation-status";

                apiKeyModal.classList.add("show");
            }

            function closeApiKeyModal() {
                apiKeyModal.classList.remove("show");
            }

            async function validateApiKey(provider, key) {
                if (!key) return { valid: false, message: "" };

                modalValidationStatus.className =
                    "modal-validation-status checking";
                modalValidationStatus.textContent = "â³ Validating API key...";

                try {
                    let endpoint = "";
                    let headers = {};
                    let method = "GET";
                    let body = null;

                    switch (provider) {
                        case "openai":
                            endpoint = "https://api.openai.com/v1/models";
                            headers = { Authorization: `Bearer ${key}` };
                            break;
                        case "google":
                            endpoint = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                            break;
                        case "anthropic":
                            endpoint = "https://api.anthropic.com/v1/messages";
                            method = "POST";
                            headers = {
                                "Content-Type": "application/json",
                                "x-api-key": key,
                                "anthropic-version": "2023-06-01",
                                "anthropic-dangerous-direct-browser-access":
                                    "true",
                            };
                            body = JSON.stringify({
                                model: "claude-3-haiku-20240307",
                                max_tokens: 1,
                                messages: [{ role: "user", content: "test" }],
                            });
                            break;
                        case "xai":
                            endpoint = "https://api.x.ai/v1/models";
                            headers = { Authorization: `Bearer ${key}` };
                            break;
                        case "deepseek":
                            endpoint = "https://api.deepseek.com/v1/models";
                            headers = { Authorization: `Bearer ${key}` };
                            break;
                        case "perplexity":
                            endpoint =
                                "https://api.perplexity.ai/chat/completions";
                            method = "POST";
                            headers = {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${key}`,
                            };
                            body = JSON.stringify({
                                model: "sonar",
                                messages: [{ role: "user", content: "test" }],
                            });
                            break;
                        case "mistral":
                            endpoint = "https://api.mistral.ai/v1/models";
                            headers = { Authorization: `Bearer ${key}` };
                            break;
                    }

                    const fetchOptions = {
                        method: method,
                        headers: headers,
                    };

                    if (body) {
                        fetchOptions.body = body;
                    }

                    const response = await fetch(endpoint, fetchOptions);

                    if (response.ok) {
                        modalValidationStatus.className =
                            "modal-validation-status valid";
                        modalValidationStatus.textContent =
                            "âœ“ API key is valid";
                        return { valid: true, message: "Valid" };
                    } else if (
                        response.status === 401 ||
                        response.status === 403
                    ) {
                        modalValidationStatus.className =
                            "modal-validation-status invalid";
                        modalValidationStatus.textContent = "âœ— Invalid API key";
                        return { valid: false, message: "Invalid" };
                    } else {
                        modalValidationStatus.className =
                            "modal-validation-status invalid";
                        modalValidationStatus.textContent = `âœ— Error: ${response.status}`;
                        return { valid: false, message: "Error" };
                    }
                } catch (error) {
                    modalValidationStatus.className =
                        "modal-validation-status invalid";
                    modalValidationStatus.textContent =
                        "âœ— Validation failed (network error)";
                    return { valid: false, message: "Error" };
                }
            }

            apiKeyBtn.addEventListener("click", openApiKeyModal);

            modalCloseBtn.addEventListener("click", closeApiKeyModal);

            apiKeyModal.addEventListener("click", (e) => {
                if (e.target === apiKeyModal) {
                    closeApiKeyModal();
                }
            });

            modalToggleVisibility.addEventListener("click", () => {
                if (modalApiKeyInput.type === "password") {
                    modalApiKeyInput.type = "text";
                } else {
                    modalApiKeyInput.type = "password";
                }
            });

            modalApiKeyInput.addEventListener("input", () => {
                // Clear validation status when user types
                modalValidationStatus.textContent = "";
                modalValidationStatus.className = "modal-validation-status";
            });

            modalSaveBtn.addEventListener("click", async () => {
                const provider = providerSelect.value;
                const key = modalApiKeyInput.value.trim();

                if (key) {
                    // Validate the key
                    const result = await validateApiKey(provider, key);

                    if (result.valid) {
                        apiKeys[provider] = key;
                        const storageKeys = {
                            openai: APIKEY_OPENAI_STORAGE_KEY,
                            google: APIKEY_GOOGLE_STORAGE_KEY,
                            anthropic: APIKEY_ANTHROPIC_STORAGE_KEY,
                            xai: APIKEY_XAI_STORAGE_KEY,
                            deepseek: APIKEY_DEEPSEEK_STORAGE_KEY,
                            perplexity: APIKEY_PERPLEXITY_STORAGE_KEY,
                            mistral: APIKEY_MISTRAL_STORAGE_KEY,
                        };
                        const validationKeys = {
                            openai: APIKEY_OPENAI_VALID_KEY,
                            google: APIKEY_GOOGLE_VALID_KEY,
                            anthropic: APIKEY_ANTHROPIC_VALID_KEY,
                            xai: APIKEY_XAI_VALID_KEY,
                            deepseek: APIKEY_DEEPSEEK_VALID_KEY,
                            perplexity: APIKEY_PERPLEXITY_VALID_KEY,
                            mistral: APIKEY_MISTRAL_VALID_KEY,
                        };

                        localStorage.setItem(storageKeys[provider], key);
                        localStorage.setItem(validationKeys[provider], "true");

                        updateApiKeyStatus();
                        updateStatus(
                            "API key saved and validated successfully",
                            "success",
                        );

                        // Update status indicator to valid
                        apiKeyStatus.classList.remove("no-key", "has-key");
                        apiKeyStatus.classList.add("valid-key");
                        apiKeyStatus.title = "Valid API key";

                        setTimeout(() => closeApiKeyModal(), 1000);
                    }
                } else {
                    modalValidationStatus.className =
                        "modal-validation-status invalid";
                    modalValidationStatus.textContent =
                        "âœ— Please enter an API key";
                }
            });

            modalClearBtn.addEventListener("click", () => {
                const provider = providerSelect.value;
                apiKeys[provider] = "";
                modalApiKeyInput.value = "";

                const storageKeys = {
                    openai: APIKEY_OPENAI_STORAGE_KEY,
                    google: APIKEY_GOOGLE_STORAGE_KEY,
                    anthropic: APIKEY_ANTHROPIC_STORAGE_KEY,
                    xai: APIKEY_XAI_STORAGE_KEY,
                    deepseek: APIKEY_DEEPSEEK_STORAGE_KEY,
                    perplexity: APIKEY_PERPLEXITY_STORAGE_KEY,
                    mistral: APIKEY_MISTRAL_STORAGE_KEY,
                };
                const validationKeys = {
                    openai: APIKEY_OPENAI_VALID_KEY,
                    google: APIKEY_GOOGLE_VALID_KEY,
                    anthropic: APIKEY_ANTHROPIC_VALID_KEY,
                    xai: APIKEY_XAI_VALID_KEY,
                    deepseek: APIKEY_DEEPSEEK_VALID_KEY,
                    perplexity: APIKEY_PERPLEXITY_VALID_KEY,
                    mistral: APIKEY_MISTRAL_VALID_KEY,
                };

                localStorage.removeItem(storageKeys[provider]);
                localStorage.removeItem(validationKeys[provider]);

                updateApiKeyStatus();
                updateStatus("API key cleared", "warning");
                closeApiKeyModal();
            });

            // Validate all stored API keys on startup
            async function validateAllKeys() {
                const providers = [
                    "openai",
                    "google",
                    "anthropic",
                    "xai",
                    "deepseek",
                    "perplexity",
                    "mistral",
                ];
                const validationKeys = {
                    openai: APIKEY_OPENAI_VALID_KEY,
                    google: APIKEY_GOOGLE_VALID_KEY,
                    anthropic: APIKEY_ANTHROPIC_VALID_KEY,
                    xai: APIKEY_XAI_VALID_KEY,
                    deepseek: APIKEY_DEEPSEEK_VALID_KEY,
                    perplexity: APIKEY_PERPLEXITY_VALID_KEY,
                    mistral: APIKEY_MISTRAL_VALID_KEY,
                };

                const providerNames = {
                    openai: "OpenAI",
                    google: "Google",
                    anthropic: "Anthropic",
                    xai: "xAI",
                    deepseek: "DeepSeek",
                    perplexity: "Perplexity",
                    mistral: "Mistral",
                };

                let validatedCount = 0;
                let invalidCount = 0;
                let totalToValidate = 0;
                let failedProviders = [];

                // Count how many keys need validation
                for (const provider of providers) {
                    if (apiKeys[provider]) {
                        totalToValidate++;
                    }
                }

                // Show status if there are keys to validate
                if (totalToValidate > 0) {
                    updateStatus(
                        `Validating ${totalToValidate} API key(s)...`,
                        "warning",
                    );
                }

                for (const provider of providers) {
                    const key = apiKeys[provider];
                    if (key) {
                        try {
                            // Silently validate each key
                            const result = await validateApiKeySilent(
                                provider,
                                key,
                            );
                            if (result.valid) {
                                localStorage.setItem(
                                    validationKeys[provider],
                                    "true",
                                );
                                validatedCount++;
                            } else {
                                localStorage.removeItem(
                                    validationKeys[provider],
                                );
                                invalidCount++;
                                failedProviders.push(providerNames[provider]);
                            }
                        } catch (error) {
                            // If validation fails, remove the validation status
                            localStorage.removeItem(validationKeys[provider]);
                            invalidCount++;
                            failedProviders.push(providerNames[provider]);
                        }
                    }
                }

                // Update status for current provider after all validations
                updateApiKeyStatus();

                // Show completion message
                if (totalToValidate > 0) {
                    if (invalidCount === 0) {
                        updateStatus(
                            `âœ“ All ${validatedCount} API key(s) validated successfully`,
                            "success",
                        );
                    } else if (validatedCount > 0) {
                        updateStatus(
                            `âš  ${validatedCount} key(s) valid, ${invalidCount} invalid (${failedProviders.join(", ")})`,
                            "warning",
                        );
                    } else {
                        updateStatus(
                            `âœ— All ${invalidCount} API key(s) failed validation (${failedProviders.join(", ")})`,
                            "error",
                        );
                    }
                }
            }

            // Silent validation (no UI updates)
            async function validateApiKeySilent(provider, key) {
                if (!key) return { valid: false, message: "" };

                try {
                    let endpoint = "";
                    let headers = {};
                    let method = "GET";
                    let body = null;

                    switch (provider) {
                        case "openai":
                            endpoint = "https://api.openai.com/v1/models";
                            headers = { Authorization: `Bearer ${key}` };
                            break;
                        case "google":
                            endpoint = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                            break;
                        case "anthropic":
                            endpoint = "https://api.anthropic.com/v1/messages";
                            method = "POST";
                            headers = {
                                "Content-Type": "application/json",
                                "x-api-key": key,
                                "anthropic-version": "2023-06-01",
                                "anthropic-dangerous-direct-browser-access":
                                    "true",
                            };
                            body = JSON.stringify({
                                model: "claude-3-haiku-20240307",
                                max_tokens: 1,
                                messages: [{ role: "user", content: "test" }],
                            });
                            break;
                        case "xai":
                            endpoint = "https://api.x.ai/v1/models";
                            headers = { Authorization: `Bearer ${key}` };
                            break;
                        case "deepseek":
                            endpoint = "https://api.deepseek.com/v1/models";
                            headers = { Authorization: `Bearer ${key}` };
                            break;
                        case "perplexity":
                            endpoint =
                                "https://api.perplexity.ai/chat/completions";
                            method = "POST";
                            headers = {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${key}`,
                            };
                            body = JSON.stringify({
                                model: "sonar",
                                messages: [{ role: "user", content: "test" }],
                            });
                            break;
                        case "mistral":
                            endpoint = "https://api.mistral.ai/v1/models";
                            headers = { Authorization: `Bearer ${key}` };
                            break;
                    }

                    const fetchOptions = {
                        method: method,
                        headers: headers,
                    };

                    if (body) {
                        fetchOptions.body = body;
                    }

                    const response = await fetch(endpoint, fetchOptions);

                    if (response.ok) {
                        return { valid: true, message: "Valid" };
                    } else if (
                        response.status === 401 ||
                        response.status === 403
                    ) {
                        return { valid: false, message: "Invalid" };
                    } else {
                        return { valid: false, message: "Error" };
                    }
                } catch (error) {
                    return { valid: false, message: "Error" };
                }
            }

            // ========= ATTACH FILES =========
            function renderAttachments() {
                const count = attachedFiles.length;

                // Show/hide refresh button based on attachment count
                refreshFilesBtn.style.display =
                    count > 0 ? "inline-flex" : "none";

                // Render in input area
                inputAttachmentsList.innerHTML = "";

                if (count > 0) {
                    attachedFiles.forEach((f, idx) => {
                        const pill = document.createElement("div");
                        pill.className = "input-attachment-pill";

                        // Add toggle state styling
                        if (f.include === false) {
                            pill.style.opacity = "0.4";
                            pill.style.background = "#1f2937";
                            pill.style.borderColor = "#374151";
                        }

                        // Make the pill clickable to toggle inclusion
                        pill.style.cursor = "pointer";

                        const label = document.createElement("span");
                        label.textContent = f.name;
                        label.title = `${f.name} - Click to ${f.include !== false ? "exclude" : "include"}`;

                        // Toggle attachment inclusion when clicking the pill
                        pill.addEventListener("click", (e) => {
                            // Don't toggle if clicking the remove button
                            if (e.target === removeBtn) return;

                            attachedFiles[idx].include =
                                !attachedFiles[idx].include;
                            renderAttachments();
                            saveConversationToLocal();
                            const status = attachedFiles[idx].include
                                ? "included"
                                : "excluded";
                            updateStatus(
                                `Attachment ${status} from context.`,
                                "success",
                            );
                        });

                        const removeBtn = document.createElement("button");
                        removeBtn.className = "input-attachment-remove";
                        removeBtn.textContent = "Ã—";
                        removeBtn.title = "Remove attachment";

                        removeBtn.addEventListener("click", (e) => {
                            e.stopPropagation(); // Prevent toggling when removing
                            attachedFiles.splice(idx, 1);
                            attachedFileObjects.splice(idx, 1);
                            renderAttachments();
                            saveConversationToLocal();
                            updateStatus("Removed attachment.", "success");
                        });

                        pill.appendChild(label);
                        pill.appendChild(removeBtn);
                        inputAttachmentsList.appendChild(pill);
                    });
                }
            }

            // Helper function to detect if file is a PDF
            function isPDFFile(file) {
                return (
                    file.type === "application/pdf" ||
                    file.name.toLowerCase().endsWith(".pdf")
                );
            }

            // Helper function to detect if file is a DOCX
            function isDOCXFile(file) {
                return (
                    file.type ===
                        "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ||
                    file.name.toLowerCase().endsWith(".docx")
                );
            }

            // Helper function to detect if file is an image
            function isImageFile(file) {
                const imageTypes = [
                    "image/jpeg",
                    "image/jpg",
                    "image/png",
                    "image/gif",
                    "image/webp",
                ];
                return (
                    imageTypes.includes(file.type) ||
                    /\.(jpg|jpeg|png|gif|webp)$/i.test(file.name)
                );
            }

            // Helper function to detect if file needs base64 encoding
            function needsBase64(file) {
                return isPDFFile(file) || isDOCXFile(file) || isImageFile(file);
            }

            function handleAttachedFiles(files) {
                if (!files.length) return;
                const readers = [];

                // File size limit: 2MB for binary files (base64 encoding increases size by ~33%)
                // This prevents context window overflow (200K tokens â‰ˆ 2-3MB of base64 PDF)
                const MAX_BINARY_FILE_SIZE = 2 * 1024 * 1024;

                for (const file of files) {
                    const isPDF = isPDFFile(file);
                    const isDOCX = isDOCXFile(file);
                    const isImage = isImageFile(file);
                    const useBase64 = needsBase64(file);

                    // Check file size for binary files - reject if too large
                    if (useBase64 && file.size > MAX_BINARY_FILE_SIZE) {
                        updateStatus(
                            `Error: File "${file.name}" (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 2MB limit. Binary files larger than 2MB will cause context window overflow. Please use a smaller file.`,
                            "error",
                        );
                        continue; // Skip this file
                    }

                    // Store the File object for future re-reading
                    attachedFileObjects.push(file);

                    const reader = new FileReader();

                    readers.push(
                        new Promise((resolve, reject) => {
                            reader.onload = () => {
                                attachedFiles.push({
                                    name: file.name,
                                    content: reader.result,
                                    include: true, // Default to included
                                    type: file.type,
                                    isPDF: isPDF,
                                    isDOCX: isDOCX,
                                    isImage: isImage,
                                });
                                resolve();
                            };
                            reader.onerror = reject;
                            // Read PDFs, DOCX, and images as base64, others as text
                            if (useBase64) {
                                reader.readAsDataURL(file);
                            } else {
                                reader.readAsText(file);
                            }
                        }),
                    );
                }

                Promise.all(readers)
                    .then(() => {
                        updateStatus(
                            `Loaded ${attachedFiles.length} attached file(s).`,
                            "success",
                        );
                        renderAttachments();
                        saveConversationToLocal();
                    })
                    .catch((err) => {
                        console.error(err);
                        updateStatus(
                            "Error reading files: " + err.message,
                            "error",
                        );
                    });
            }

            // Function to refresh/re-read all attached files
            function refreshAttachedFiles() {
                if (attachedFileObjects.length === 0) {
                    updateStatus("No files to refresh.", "warning");
                    return;
                }

                const readers = [];
                const newAttachedFiles = [];

                for (const file of attachedFileObjects) {
                    const reader = new FileReader();
                    const isPDF = isPDFFile(file);
                    const isDOCX = isDOCXFile(file);
                    const isImage = isImageFile(file);
                    const useBase64 = needsBase64(file);

                    readers.push(
                        new Promise((resolve, reject) => {
                            reader.onload = () => {
                                newAttachedFiles.push({
                                    name: file.name,
                                    content: reader.result,
                                    type: file.type,
                                    isPDF: isPDF,
                                    isDOCX: isDOCX,
                                    isImage: isImage,
                                });
                                resolve();
                            };
                            reader.onerror = reject;
                            // Read PDFs, DOCX, and images as base64, others as text
                            if (useBase64) {
                                reader.readAsDataURL(file);
                            } else {
                                reader.readAsText(file);
                            }
                        }),
                    );
                }

                Promise.all(readers)
                    .then(() => {
                        attachedFiles = newAttachedFiles;
                        updateStatus(
                            `Refreshed ${attachedFiles.length} file(s) from disk.`,
                            "success",
                        );
                        renderAttachments();
                        saveConversationToLocal();
                    })
                    .catch((err) => {
                        console.error(err);
                        updateStatus(
                            "Error refreshing files: " + err.message,
                            "error",
                        );
                    });
            }

            // Render refresh dropdown
            function renderRefreshDropdown() {
                refreshDropdown.innerHTML = "";

                if (attachedFileObjects.length === 0) {
                    // Show message that files need to be re-attached
                    const message = document.createElement("div");
                    message.style.cssText =
                        "padding: 8px; font-size: 12px; color: #9ca3af; text-align: center;";
                    message.textContent =
                        "Files from previous session cannot be refreshed. Please re-attach files to enable refresh.";
                    refreshDropdown.appendChild(message);
                    return;
                }

                attachedFileObjects.forEach((file, idx) => {
                    const option = document.createElement("div");
                    option.className = "refresh-option";

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.checked = true;
                    checkbox.dataset.index = idx;

                    const label = document.createElement("span");
                    label.className = "refresh-option-label";
                    label.textContent = file.name;
                    label.title = file.name;

                    option.appendChild(checkbox);
                    option.appendChild(label);
                    option.addEventListener("click", (e) => {
                        if (e.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                        }
                    });

                    refreshDropdown.appendChild(option);
                });

                // Add action buttons
                const actions = document.createElement("div");
                actions.className = "refresh-dropdown-actions";

                const selectAllBtn = document.createElement("button");
                selectAllBtn.className = "refresh-dropdown-btn";
                selectAllBtn.textContent = "Select All";
                selectAllBtn.addEventListener("click", () => {
                    refreshDropdown
                        .querySelectorAll('input[type="checkbox"]')
                        .forEach((cb) => {
                            cb.checked = true;
                        });
                });

                const refreshBtn = document.createElement("button");
                refreshBtn.className = "refresh-dropdown-btn primary";
                refreshBtn.textContent = "Refresh Selected";
                refreshBtn.addEventListener("click", () => {
                    const selected = Array.from(
                        refreshDropdown.querySelectorAll(
                            'input[type="checkbox"]',
                        ),
                    )
                        .map((cb, idx) =>
                            cb.checked ? parseInt(cb.dataset.index) : -1,
                        )
                        .filter((idx) => idx !== -1);

                    if (selected.length === 0) {
                        updateStatus(
                            "No files selected to refresh.",
                            "warning",
                        );
                        return;
                    }

                    refreshSelectedFiles(selected);
                    refreshDropdown.classList.remove("show");
                });

                actions.appendChild(selectAllBtn);
                actions.appendChild(refreshBtn);
                refreshDropdown.appendChild(actions);
            }

            // Refresh only selected files
            function refreshSelectedFiles(indices) {
                const readers = [];
                const newAttachedFiles = [...attachedFiles];

                indices.forEach((idx) => {
                    const file = attachedFileObjects[idx];
                    const reader = new FileReader();
                    const isPDF = isPDFFile(file);
                    const isDOCX = isDOCXFile(file);
                    const isImage = isImageFile(file);
                    const useBase64 = needsBase64(file);

                    readers.push(
                        new Promise((resolve, reject) => {
                            reader.onload = () => {
                                newAttachedFiles[idx] = {
                                    name: file.name,
                                    content: reader.result,
                                    type: file.type,
                                    isPDF: isPDF,
                                    isDOCX: isDOCX,
                                    isImage: isImage,
                                };
                                resolve();
                            };
                            reader.onerror = reject;
                            // Read PDFs, DOCX, and images as base64, others as text
                            if (useBase64) {
                                reader.readAsDataURL(file);
                            } else {
                                reader.readAsText(file);
                            }
                        }),
                    );
                });

                Promise.all(readers)
                    .then(() => {
                        attachedFiles = newAttachedFiles;
                        updateStatus(
                            `Refreshed ${indices.length} file(s) from disk.`,
                            "success",
                        );
                        renderAttachments();
                        saveConversationToLocal();
                    })
                    .catch((err) => {
                        console.error(err);
                        updateStatus(
                            "Error refreshing files: " + err.message,
                            "error",
                        );
                    });
            }

            attachBtnInput.addEventListener("click", () =>
                attachFileInput.click(),
            );

            refreshFilesBtn.addEventListener("click", (e) => {
                renderRefreshDropdown();

                if (refreshDropdown.classList.contains("show")) {
                    refreshDropdown.classList.remove("show");
                } else {
                    // Position dropdown above the button
                    const btnRect = refreshFilesBtn.getBoundingClientRect();
                    const inputAreaRect = document
                        .getElementById("input-area")
                        .getBoundingClientRect();

                    refreshDropdown.style.bottom =
                        inputAreaRect.bottom - btnRect.top + 10 + "px";
                    refreshDropdown.style.right =
                        inputAreaRect.right - btnRect.right + "px";

                    refreshDropdown.classList.add("show");
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener("click", (e) => {
                if (
                    !refreshFilesBtn.contains(e.target) &&
                    !refreshDropdown.contains(e.target)
                ) {
                    refreshDropdown.classList.remove("show");
                }
            });

            attachFileInput.addEventListener("change", (e) => {
                const files = Array.from(e.target.files || []);
                handleAttachedFiles(files);
                attachFileInput.value = "";
            });

            // ========= DRAG AND DROP FUNCTIONALITY =========
            const inputArea = document.getElementById("input-area");
            const inputInner = document.getElementById("input-inner");
            const dragDropOverlay =
                document.querySelector(".drag-drop-overlay");
            let dragCounter = 0;

            // Prevent default drag behaviors on the whole document
            ["dragenter", "dragover", "dragleave", "drop"].forEach(
                (eventName) => {
                    document.body.addEventListener(
                        eventName,
                        (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        },
                        false,
                    );
                },
            );

            // Handle drag enter on input area
            inputArea.addEventListener("dragenter", (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragCounter++;

                if (e.dataTransfer.types.includes("Files")) {
                    inputArea.classList.add("drag-over");
                    inputInner.classList.add("drag-over");
                    dragDropOverlay.classList.add("show");
                }
            });

            // Handle drag over on input area
            inputArea.addEventListener("dragover", (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = "copy";
                }
            });

            // Handle drag leave on input area
            inputArea.addEventListener("dragleave", (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragCounter--;

                if (dragCounter === 0) {
                    inputArea.classList.remove("drag-over");
                    inputInner.classList.remove("drag-over");
                    dragDropOverlay.classList.remove("show");
                }
            });

            // Handle drop on input area
            inputArea.addEventListener("drop", (e) => {
                e.preventDefault();
                e.stopPropagation();

                dragCounter = 0;
                inputArea.classList.remove("drag-over");
                inputInner.classList.remove("drag-over");
                dragDropOverlay.classList.remove("show");

                const files = Array.from(e.dataTransfer.files || []);
                if (files.length > 0) {
                    handleAttachedFiles(files);
                    updateStatus(
                        `Added ${files.length} file(s) via drag & drop`,
                        "success",
                    );
                }
            });

            // ========= LOCAL CONVERSATION STORAGE =========
            function saveConversationToLocal() {
                try {
                    // Strip images from assistant responses before saving
                    const pairsToSave = conversationPairs.map((pair) => ({
                        ...pair,
                        assistant: stripImages(pair.assistant),
                    }));

                    const data = {
                        pairs: pairsToSave,
                        attachments: attachedFiles,
                        chatName: currentChatName || "",
                    };
                    localStorage.setItem(
                        CONVO_STORAGE_KEY,
                        JSON.stringify(data),
                    );

                    // Check if current state differs from last exported state
                    if (lastExportedState !== null) {
                        const currentState = JSON.stringify(data);
                        hasUnsavedChangesFlag =
                            currentState !== lastExportedState;
                    }
                } catch (e) {
                    console.warn(
                        "Failed to save conversation to localStorage:",
                        e,
                    );
                }
            }

            function loadConversationFromLocal() {
                try {
                    const raw = localStorage.getItem(CONVO_STORAGE_KEY);
                    if (!raw) return;

                    const data = JSON.parse(raw);

                    if (Array.isArray(data.pairs)) {
                        conversationPairs = data.pairs.map((p) => ({
                            user: p.user || "",
                            assistant: p.assistant || "",
                            t: p.t || Date.now(),
                            include: p.include !== false,
                            collapsed: !!p.collapsed,
                            provider: p.provider || null,
                            elapsedMs: p.elapsedMs || null,
                            pinned: !!p.pinned,
                        }));
                    }

                    if (Array.isArray(data.attachments)) {
                        attachedFiles = data.attachments.map((f) => ({
                            name: f.name || "unnamed",
                            content: f.content || "",
                        }));
                    }

                    // Load chat name from localStorage data
                    if (typeof data.chatName === "string") {
                        currentChatName = data.chatName;
                        localStorage.setItem(
                            CHATNAME_STORAGE_KEY,
                            data.chatName,
                        );
                    }
                } catch (e) {
                    console.warn(
                        "Failed to load conversation from localStorage:",
                        e,
                    );
                }
            }

            // ========= PAGINATION =========
            function getTotalPages() {
                return Math.max(
                    1,
                    Math.ceil(conversationPairs.length / PAGE_SIZE),
                );
            }

            function renderPage() {
                const totalPages = getTotalPages();
                if (currentPage > totalPages) currentPage = totalPages;
                if (currentPage < 1) currentPage = 1;

                const startIndex = Math.max(
                    0,
                    conversationPairs.length - currentPage * PAGE_SIZE,
                );
                const endIndex = Math.min(
                    conversationPairs.length,
                    startIndex + PAGE_SIZE,
                );

                const pagePairs = conversationPairs.slice(startIndex, endIndex);

                messagesDiv.innerHTML = "";

                // Render page pairs
                for (let i = pagePairs.length - 1; i >= 0; i--) {
                    const pair = pagePairs[i];
                    const globalIndex = startIndex + i;

                    // ===== COLLAPSED VIEW =====
                    if (pair.collapsed) {
                        const row = document.createElement("div");
                        row.className = "message-row collapsed-summary";

                        // Add visual indicator if pinned
                        if (pair.pinned) {
                            row.style.borderLeft = "3px solid #3b82f6";
                            row.style.paddingLeft = "9px";
                            row.style.background = "rgba(59, 130, 246, 0.05)";
                        }

                        const avatarContainer = document.createElement("div");
                        avatarContainer.className = "collapsed-avatars";

                        const userAvatar = document.createElement("div");
                        userAvatar.className = "avatar user";
                        renderUserAvatar(userAvatar);
                        userAvatar.addEventListener("click", () => {
                            avatarFileInput.click();
                        });

                        const assistantAvatar = document.createElement("div");
                        assistantAvatar.className = "avatar assistant";
                        if (pair.provider) {
                            assistantAvatar.classList.add(pair.provider);
                        }

                        // Render avatar (custom or default)
                        renderAssistantAvatar(assistantAvatar, pair.provider);

                        // Make clickable for custom avatar upload
                        assistantAvatar.addEventListener("click", () => {
                            pendingAvatarProvider = pair.provider;
                            avatarFileInput.click();
                        });

                        avatarContainer.appendChild(userAvatar);
                        avatarContainer.appendChild(assistantAvatar);

                        const content = document.createElement("div");
                        content.className = "message-content";

                        const meta = document.createElement("div");
                        meta.className = "message-meta";

                        const metaLeft = document.createElement("div");
                        metaLeft.className = "meta-left";

                        const label = document.createElement("span");
                        label.textContent = "Collapsed pair";

                        metaLeft.appendChild(label);
                        meta.appendChild(metaLeft);

                        // Expand button goes in the meta row (same place as Collapse)
                        const expandBtn = document.createElement("button");
                        expandBtn.className = "copy-btn";
                        expandBtn.textContent = "Expand pair";
                        expandBtn.addEventListener("click", () => {
                            conversationPairs[globalIndex].collapsed = false;
                            saveConversationToLocal();
                            renderPage();
                        });
                        meta.appendChild(expandBtn);

                        const bubble = document.createElement("div");
                        bubble.className = "collapsed-summary-bubble";

                        const userPreview = (pair.user || "").slice(0, 80);
                        bubble.textContent =
                            (userPreview || "(empty prompt)") +
                            (pair.user && pair.user.length > 80 ? "â€¦" : "");

                        content.appendChild(meta);
                        content.appendChild(bubble);

                        row.appendChild(avatarContainer);
                        row.appendChild(content);
                        messagesDiv.appendChild(row);
                        continue;
                    }

                    // ===== EXPANDED USER ROW =====
                    const userRow = document.createElement("div");
                    userRow.className = "message-row";

                    // Add visual indicator if pinned
                    if (pair.pinned) {
                        userRow.style.borderLeft = "3px solid #3b82f6";
                        userRow.style.paddingLeft = "9px";
                        userRow.style.background = "rgba(59, 130, 246, 0.05)";
                    }

                    const userAvatar = document.createElement("div");
                    userAvatar.className = "avatar user";
                    renderUserAvatar(userAvatar);
                    userAvatar.addEventListener("click", () => {
                        avatarFileInput.click();
                    });

                    const userContent = document.createElement("div");
                    userContent.className = "message-content";

                    const userMeta = document.createElement("div");
                    userMeta.className = "message-meta";

                    const metaLeft = document.createElement("div");
                    metaLeft.className = "meta-left";

                    const youLabel = document.createElement("span");
                    youLabel.textContent = "You";

                    const includeLabel = document.createElement("label");
                    includeLabel.className = "include-toggle";

                    const includeCheckbox = document.createElement("input");
                    includeCheckbox.type = "checkbox";
                    includeCheckbox.checked = pair.include !== false;
                    includeCheckbox.dataset.index = String(globalIndex);

                    includeCheckbox.addEventListener("change", (e) => {
                        const idx = parseInt(e.target.dataset.index, 10);
                        if (!Number.isNaN(idx) && conversationPairs[idx]) {
                            conversationPairs[idx].include = e.target.checked;
                            saveConversationToLocal();
                        }
                    });

                    const includeText = document.createElement("span");
                    includeText.textContent = "Include in context";

                    includeLabel.appendChild(includeCheckbox);
                    includeLabel.appendChild(includeText);

                    // Pin to context button
                    const pinLabel = document.createElement("label");
                    pinLabel.className = "include-toggle";
                    pinLabel.style.marginLeft = "12px";

                    const pinCheckbox = document.createElement("input");
                    pinCheckbox.type = "checkbox";
                    pinCheckbox.checked = !!pair.pinned;
                    pinCheckbox.dataset.index = String(globalIndex);

                    pinCheckbox.addEventListener("change", (e) => {
                        const idx = parseInt(e.target.dataset.index, 10);
                        if (!Number.isNaN(idx) && conversationPairs[idx]) {
                            conversationPairs[idx].pinned = e.target.checked;
                            // When pinning, uncheck "include as context"
                            if (e.target.checked) {
                                conversationPairs[idx].include = false;
                            }
                            saveConversationToLocal();
                            renderPage(); // Re-render to show pin indicator
                        }
                    });

                    const pinText = document.createElement("span");
                    pinText.textContent = "ðŸ“Œ Pin to context";
                    pinText.title =
                        "Always include in context (doesn't count toward history limit)";

                    pinLabel.appendChild(pinCheckbox);
                    pinLabel.appendChild(pinText);

                    metaLeft.appendChild(youLabel);
                    metaLeft.appendChild(includeLabel);
                    metaLeft.appendChild(pinLabel);
                    userMeta.appendChild(metaLeft);

                    // Create container for action buttons (grouped together)
                    const metaRight = document.createElement("div");
                    metaRight.style.display = "inline-flex";
                    metaRight.style.gap = "6px";

                    // Retry prompt button
                    const retryBtn = document.createElement("button");
                    retryBtn.className = "copy-btn";
                    retryBtn.textContent = "Retry prompt";
                    retryBtn.addEventListener("click", async () => {
                        retryBtn.disabled = true;
                        retryBtn.textContent = "Retrying...";

                        try {
                            const currentProvider = providerSelect.value;
                            const currentModel = modelSelect.value;
                            const apiKey = getApiKey();

                            if (!apiKey) {
                                updateStatus(
                                    `Please set an API key for ${currentProvider} first.`,
                                    "error",
                                );
                                retryBtn.disabled = false;
                                retryBtn.textContent = "Retry prompt";
                                return;
                            }

                            // Uncheck the old pair from context instead of deleting
                            conversationPairs[globalIndex].include = false;
                            saveConversationToLocal();

                            // Put the original prompt in the input field and send
                            const originalPrompt = pair.user;
                            userInput.value = originalPrompt;

                            await sendMessage();

                            retryBtn.disabled = false;
                            retryBtn.textContent = "Retry prompt";
                        } catch (err) {
                            console.error("Retry failed:", err);
                            updateStatus(
                                "Retry failed: " + err.message,
                                "error",
                            );
                            retryBtn.disabled = false;
                            retryBtn.textContent = "Retry prompt";
                        }
                    });
                    metaRight.appendChild(retryBtn);

                    // Delete pair button
                    const deletePairBtn = document.createElement("button");
                    deletePairBtn.className = "copy-btn";
                    deletePairBtn.textContent = "Delete pair";
                    deletePairBtn.style.color = "#ef4444";
                    deletePairBtn.addEventListener("click", () => {
                        const confirmed = confirm(
                            "Are you sure you want to delete this prompt/response pair?\n\n" +
                                "This action cannot be undone.",
                        );
                        if (confirmed) {
                            conversationPairs.splice(globalIndex, 1);
                            saveConversationToLocal();
                            renderPage();
                            updateStatus(
                                "Pair deleted successfully.",
                                "success",
                            );
                        }
                    });
                    metaRight.appendChild(deletePairBtn);

                    // Collapse pair button (right)
                    const collapsePairBtn = document.createElement("button");
                    collapsePairBtn.className = "copy-btn";
                    collapsePairBtn.textContent = "Collapse pair";
                    collapsePairBtn.addEventListener("click", () => {
                        conversationPairs[globalIndex].collapsed = true;
                        saveConversationToLocal();
                        renderPage();
                    });
                    metaRight.appendChild(collapsePairBtn);

                    userMeta.appendChild(metaRight);

                    const userBubble = document.createElement("div");
                    userBubble.className = "message-bubble user";
                    userBubble.textContent = pair.user;

                    userContent.appendChild(userMeta);
                    userContent.appendChild(userBubble);
                    userRow.appendChild(userAvatar);
                    userRow.appendChild(userContent);

                    messagesDiv.appendChild(userRow);

                    // ===== EXPANDED ASSISTANT ROW =====
                    const assistantRow = document.createElement("div");
                    assistantRow.className = "message-row assistant";

                    // Add visual indicator if pinned
                    if (pair.pinned) {
                        assistantRow.style.borderLeft = "3px solid #3b82f6";
                        assistantRow.style.paddingLeft = "9px";
                        assistantRow.style.background =
                            "rgba(59, 130, 246, 0.05)";
                    }

                    const assistantAvatar = document.createElement("div");
                    assistantAvatar.className = "avatar assistant";
                    if (pair.provider) {
                        assistantAvatar.classList.add(pair.provider);
                    }

                    // Render avatar (custom or default)
                    renderAssistantAvatar(assistantAvatar, pair.provider);

                    // Make clickable for custom avatar upload
                    assistantAvatar.addEventListener("click", () => {
                        pendingAvatarProvider = pair.provider;
                        avatarFileInput.click();
                    });

                    const assistantContent = document.createElement("div");
                    assistantContent.className = "message-content";

                    const assistantMeta = document.createElement("div");
                    assistantMeta.className = "message-meta";

                    const metaLeftA = document.createElement("div");
                    metaLeftA.className = "meta-left";

                    const assistantLabel = document.createElement("span");
                    assistantLabel.textContent = "Assistant";

                    metaLeftA.appendChild(assistantLabel);

                    // Add elapsed time if available
                    if (
                        pair.elapsedMs !== null &&
                        pair.elapsedMs !== undefined
                    ) {
                        const elapsedSpan = document.createElement("span");
                        elapsedSpan.className = "thinking-timer";
                        const seconds = Math.floor(pair.elapsedMs / 1000);
                        const ms = Math.floor((pair.elapsedMs % 1000) / 10);
                        elapsedSpan.textContent = `(${seconds}.${ms.toString().padStart(2, "0")}s)`;
                        metaLeftA.appendChild(elapsedSpan);
                    }

                    assistantMeta.appendChild(metaLeftA);

                    // Copy response button
                    const copyResponseBtn = document.createElement("button");
                    copyResponseBtn.className = "copy-btn";
                    copyResponseBtn.textContent = "Copy response";
                    copyResponseBtn.addEventListener("click", () => {
                        navigator.clipboard
                            .writeText(pair.assistant)
                            .then(() => {
                                copyResponseBtn.textContent = "Copied!";
                                setTimeout(() => {
                                    copyResponseBtn.textContent =
                                        "Copy response";
                                }, 1500);
                            })
                            .catch((err) => {
                                console.error("Failed to copy:", err);
                                copyResponseBtn.textContent = "Failed to copy";
                                setTimeout(() => {
                                    copyResponseBtn.textContent =
                                        "Copy response";
                                }, 1500);
                            });
                    });
                    assistantMeta.appendChild(copyResponseBtn);

                    const assistantBubble = document.createElement("div");
                    assistantBubble.className = "message-bubble assistant";
                    assistantBubble.innerHTML = marked.parse(pair.assistant);

                    assistantContent.appendChild(assistantMeta);
                    assistantContent.appendChild(assistantBubble);
                    assistantRow.appendChild(assistantAvatar);
                    assistantRow.appendChild(assistantContent);

                    messagesDiv.appendChild(assistantRow);
                }

                pageInfoSpan.textContent = `Page ${currentPage} / ${getTotalPages()}`;
                prevPageBtn.disabled = currentPage >= getTotalPages();
                nextPageBtn.disabled = currentPage <= 1;

                enhanceCodeBlocks();
                messagesDiv.scrollTop = 0;
            }

            function showThinkingMessage(promptText) {
                hideThinkingMessage();

                const container = document.createElement("div");
                container.className = "pending-block";

                // user row
                const userRow = document.createElement("div");
                userRow.className = "message-row";

                const userAvatar = document.createElement("div");
                userAvatar.className = "avatar user";
                renderUserAvatar(userAvatar);
                userAvatar.addEventListener("click", () => {
                    avatarFileInput.click();
                });

                const userContent = document.createElement("div");
                userContent.className = "message-content";

                const userMeta = document.createElement("div");
                userMeta.className = "message-meta";

                const userMetaLeft = document.createElement("div");
                userMetaLeft.className = "meta-left";

                const youLabel = document.createElement("span");
                youLabel.textContent = "You";

                userMetaLeft.appendChild(youLabel);
                userMeta.appendChild(userMetaLeft);

                const userBubble = document.createElement("div");
                userBubble.className = "message-bubble user";
                userBubble.textContent = promptText;

                userContent.appendChild(userMeta);
                userContent.appendChild(userBubble);
                userRow.appendChild(userAvatar);
                userRow.appendChild(userContent);

                container.appendChild(userRow);

                // assistant thinking row
                const assistantRow = document.createElement("div");
                assistantRow.className = "message-row pending-assistant";

                const assistantAvatar = document.createElement("div");
                assistantAvatar.className = "avatar assistant";
                const currentProvider = providerSelect.value;
                if (currentProvider) {
                    assistantAvatar.classList.add(currentProvider);
                }

                // Render avatar with custom image if available
                renderAssistantAvatar(assistantAvatar, currentProvider);
                assistantAvatar.style.cursor = "pointer";
                assistantAvatar.addEventListener("click", () => {
                    pendingAvatarProvider = currentProvider;
                    avatarFileInput.click();
                });

                const assistantContent = document.createElement("div");
                assistantContent.className = "message-content";

                const assistantMeta = document.createElement("div");
                assistantMeta.className = "message-meta";

                const metaLeft = document.createElement("div");
                metaLeft.className = "meta-left";

                const assistantLabel = document.createElement("span");
                assistantLabel.textContent = "Assistant";

                const timerSpan = document.createElement("span");
                timerSpan.className = "thinking-timer";
                timerSpan.textContent = "(0s)";

                metaLeft.appendChild(assistantLabel);
                metaLeft.appendChild(timerSpan);
                assistantMeta.appendChild(metaLeft);

                const assistantBubble = document.createElement("div");
                assistantBubble.className = "message-bubble assistant thinking";

                const textSpan = document.createElement("span");
                textSpan.textContent = "Thinking";

                const dotsSpan = document.createElement("span");
                dotsSpan.className = "thinking-dots";
                dotsSpan.textContent = ".";

                assistantBubble.appendChild(textSpan);
                assistantBubble.appendChild(dotsSpan);
                assistantContent.appendChild(assistantMeta);
                assistantContent.appendChild(assistantBubble);
                assistantRow.appendChild(assistantAvatar);
                assistantRow.appendChild(assistantContent);

                container.appendChild(assistantRow);

                messagesDiv.insertBefore(container, messagesDiv.firstChild);
                pendingAssistantNode = container;

                // Start timer
                thinkingStartTime = Date.now();

                // Update dots animation
                let step = 0;
                thinkingIntervalId = setInterval(() => {
                    if (!dotsSpan.isConnected) return;
                    const dots = ".".repeat(step % 4);
                    dotsSpan.textContent = dots || ".";
                    step++;
                }, 400);

                // Update timer with milliseconds
                thinkingTimerIntervalId = setInterval(() => {
                    if (!timerSpan.isConnected) return;
                    const elapsedMs = Date.now() - thinkingStartTime;
                    const seconds = Math.floor(elapsedMs / 1000);
                    const ms = Math.floor((elapsedMs % 1000) / 10); // Show 2-digit centiseconds
                    timerSpan.textContent = `(${seconds}.${ms.toString().padStart(2, "0")}s)`;
                }, 50);
            }

            function hideThinkingMessage() {
                if (thinkingIntervalId !== null) {
                    clearInterval(thinkingIntervalId);
                    thinkingIntervalId = null;
                }
                if (thinkingTimerIntervalId !== null) {
                    clearInterval(thinkingTimerIntervalId);
                    thinkingTimerIntervalId = null;
                }
                thinkingStartTime = null;
                if (pendingAssistantNode && pendingAssistantNode.parentNode) {
                    pendingAssistantNode.parentNode.removeChild(
                        pendingAssistantNode,
                    );
                }
                pendingAssistantNode = null;
            }

            function enhanceCodeBlocks() {
                messagesDiv.querySelectorAll("pre").forEach((pre) => {
                    const code = pre.querySelector("code");

                    if (
                        code &&
                        typeof hljs !== "undefined" &&
                        hljs &&
                        typeof hljs.highlightElement === "function"
                    ) {
                        hljs.highlightElement(code);
                    }

                    if (!pre.querySelector(".code-header")) {
                        const header = document.createElement("div");
                        header.className = "code-header";

                        const psIcon = document.createElement("div");
                        psIcon.className = "ps-icon";

                        const promptSymbol = document.createElement("span");
                        promptSymbol.textContent = ">";

                        const cursor = document.createElement("span");
                        cursor.className = "ps-cursor";
                        cursor.textContent = "_";

                        psIcon.appendChild(promptSymbol);
                        psIcon.appendChild(cursor);

                        const headerControls = document.createElement("div");
                        headerControls.className = "code-header-controls";

                        const collapseTop = document.createElement("button");
                        collapseTop.className = "copy-btn";
                        collapseTop.dataset.role = "collapse-top";
                        collapseTop.textContent = pre.classList.contains(
                            "collapsed",
                        )
                            ? "Expand"
                            : "Collapse";

                        collapseTop.addEventListener("click", () => {
                            const isCollapsed =
                                pre.classList.toggle("collapsed");
                            pre.querySelectorAll(
                                '.copy-btn[data-role^="collapse"]',
                            ).forEach((btn) => {
                                btn.textContent = isCollapsed
                                    ? "Expand"
                                    : "Collapse";
                            });
                        });

                        const copyTop = document.createElement("button");
                        copyTop.className = "copy-btn";
                        copyTop.dataset.role = "copy-top";
                        copyTop.textContent = "Copy code";

                        copyTop.addEventListener("click", () => {
                            const codeEl = pre.querySelector("code");
                            const textToCopy = codeEl
                                ? codeEl.textContent.trim()
                                : "";
                            navigator.clipboard.writeText(textToCopy);
                            copyTop.textContent = "Copied!";
                            setTimeout(() => {
                                copyTop.textContent = "Copy code";
                            }, 1500);
                        });

                        headerControls.appendChild(collapseTop);
                        headerControls.appendChild(copyTop);

                        header.appendChild(psIcon);
                        header.appendChild(headerControls);
                        pre.insertBefore(header, pre.firstChild);
                    }

                    if (!pre.querySelector(".code-footer")) {
                        const footer = document.createElement("div");
                        footer.className = "code-footer";

                        const collapseBottom = document.createElement("button");
                        collapseBottom.className = "copy-btn";
                        collapseBottom.dataset.role = "collapse-bottom";
                        collapseBottom.textContent = pre.classList.contains(
                            "collapsed",
                        )
                            ? "Expand"
                            : "Collapse";

                        collapseBottom.addEventListener("click", () => {
                            const isCollapsed =
                                pre.classList.toggle("collapsed");
                            pre.querySelectorAll(
                                '.copy-btn[data-role^="collapse"]',
                            ).forEach((btn) => {
                                btn.textContent = isCollapsed
                                    ? "Expand"
                                    : "Collapse";
                            });
                        });

                        const copyBottom = document.createElement("button");
                        copyBottom.className = "copy-btn";
                        copyBottom.dataset.role = "copy-bottom";
                        copyBottom.textContent = "Copy code";

                        copyBottom.addEventListener("click", () => {
                            const codeEl = pre.querySelector("code");
                            const textToCopy = codeEl
                                ? codeEl.textContent.trim()
                                : "";
                            navigator.clipboard.writeText(textToCopy);
                            copyBottom.textContent = "Copied!";
                            setTimeout(() => {
                                copyBottom.textContent = "Copy code";
                            }, 1500);
                        });

                        footer.appendChild(collapseBottom);
                        footer.appendChild(copyBottom);
                        pre.appendChild(footer);
                    }
                });
            }

            prevPageBtn.addEventListener("click", () => {
                currentPage++;
                renderPage();
            });

            nextPageBtn.addEventListener("click", () => {
                currentPage--;
                renderPage();
            });

            // ========= NEW CHAT / EXPORT / IMPORT =========

            // Check if there are unsaved changes (changes since last export)
            function hasUnsavedChanges() {
                // If we've never exported anything, check if there's any content
                if (lastExportedState === null) {
                    return (
                        conversationPairs.length > 0 || attachedFiles.length > 0
                    );
                }

                // Otherwise check the flag
                return hasUnsavedChangesFlag;
            }

            function newChat() {
                // Check for unsaved changes
                if (hasUnsavedChanges()) {
                    const confirmed = confirm(
                        "You have unsaved changes in your current chat.\n\n" +
                            "Would you like to save this chat before starting a new one?\n\n" +
                            "Click 'OK' to go back and save, or 'Cancel' to start new chat without saving.",
                    );

                    if (confirmed) {
                        // User wants to save first
                        updateStatus(
                            "Please save your chat before starting a new one.",
                            "warning",
                        );
                        return;
                    }
                }

                conversationPairs = [];
                attachedFiles = [];
                attachedFileObjects = [];

                // Clear context/system prompt
                currentContextPrompt = "";
                localStorage.setItem(CONTEXT_STORAGE_KEY, "");

                // Clear chat name
                currentChatName = "";
                localStorage.setItem(CHATNAME_STORAGE_KEY, "");

                saveConversationToLocal();

                // Reset export tracking
                lastExportedState = null;
                hasUnsavedChangesFlag = false;

                currentPage = 1;
                renderPage();
                renderAttachments();
                updateStatus(
                    "Started new chat (API key and model kept).",
                    "success",
                );
            }

            async function exportConversation() {
                if (!conversationPairs.length && !attachedFiles.length) {
                    updateStatus(
                        "Nothing to export (no messages or attachments).",
                        "warning",
                    );
                    return;
                }

                // Strip images from assistant responses before exporting
                const pairsToExport = conversationPairs.map((pair) => ({
                    ...pair,
                    assistant: stripImages(pair.assistant),
                }));

                const data = {
                    version: 1,
                    exportedAt: new Date().toISOString(),
                    provider: providerSelect.value,
                    model: modelSelect.value,
                    context: getContextPrompt(),
                    chatName: currentChatName || "",
                    pairs: pairsToExport,
                    attachments: attachedFiles,
                };

                const jsonContent = JSON.stringify(data, null, 2);
                const timestamp = new Date()
                    .toISOString()
                    .replace(/[:.]/g, "-");
                const suggestedFilename = `${EXPORT_FILENAME_PREFIX}-${timestamp}.json`;

                // Try to use File System Access API for save-as dialog
                if ("showSaveFilePicker" in window) {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: suggestedFilename,
                            types: [
                                {
                                    description: "JSON Files",
                                    accept: { "application/json": [".json"] },
                                },
                            ],
                        });
                        const writable = await handle.createWritable();
                        await writable.write(jsonContent);
                        await writable.close();

                        // Mark as saved
                        lastExportedState = jsonContent;
                        hasUnsavedChangesFlag = false;

                        updateStatus(
                            "Conversation saved successfully.",
                            "success",
                        );
                        return;
                    } catch (err) {
                        // User cancelled or error occurred
                        if (err.name !== "AbortError") {
                            console.error("Save failed:", err);
                        } else {
                            return; // User cancelled, don't show error
                        }
                    }
                }

                // Fallback to traditional download method
                const blob = new Blob([jsonContent], {
                    type: "application/json",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = suggestedFilename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);

                // Mark as saved
                lastExportedState = jsonContent;
                hasUnsavedChangesFlag = false;

                updateStatus("Conversation exported as JSON.", "success");
            }

            function importConversation(file) {
                // Check for unsaved changes before importing
                if (hasUnsavedChanges()) {
                    const confirmed = confirm(
                        "You have unsaved changes in your current chat.\n\n" +
                            "Would you like to save this chat before loading another?\n\n" +
                            "Click 'OK' to go back and save, or 'Cancel' to load without saving.",
                    );

                    if (confirmed) {
                        // User wants to save first
                        updateStatus(
                            "Please save your current chat before loading another.",
                            "warning",
                        );
                        return;
                    }
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const text = e.target.result;
                        const data = JSON.parse(text);

                        if (!Array.isArray(data.pairs)) {
                            throw new Error(
                                "Invalid file: missing 'pairs' array.",
                            );
                        }

                        // Try to restore provider/model if valid
                        if (data.provider && MODEL_LISTS[data.provider]) {
                            providerSelect.value = data.provider;
                            updateModelOptions();

                            if (
                                data.model &&
                                MODEL_LISTS[data.provider].includes(data.model)
                            ) {
                                modelSelect.value = data.model;
                            }

                            localStorage.setItem(
                                PROVIDER_STORAGE_KEY,
                                providerSelect.value,
                            );
                            localStorage.setItem(
                                MODEL_STORAGE_KEY,
                                modelSelect.value,
                            );
                        } else if (
                            data.model &&
                            MODEL_LISTS.openai.includes(data.model)
                        ) {
                            // Legacy import fallback
                            providerSelect.value = "openai";
                            updateModelOptions();
                            modelSelect.value = data.model;
                        }

                        if (typeof data.context === "string") {
                            settingsContextInput.value = data.context;
                            localStorage.setItem(
                                CONTEXT_STORAGE_KEY,
                                data.context,
                            );
                        }

                        // Load chat name from file, or use empty string if not present
                        const chatName =
                            typeof data.chatName === "string"
                                ? data.chatName
                                : "";
                        currentChatName = chatName;
                        localStorage.setItem(CHATNAME_STORAGE_KEY, chatName);

                        conversationPairs = data.pairs.map((p) => ({
                            user: p.user || "",
                            assistant: p.assistant || "",
                            t: p.t || Date.now(),
                            include: p.include !== false,
                            collapsed: !!p.collapsed,
                            provider: p.provider || null,
                            elapsedMs: p.elapsedMs || null,
                            pinned: !!p.pinned,
                        }));

                        attachedFiles = Array.isArray(data.attachments)
                            ? data.attachments.map((f) => ({
                                  name: f.name || "unnamed",
                                  content: f.content || "",
                              }))
                            : [];

                        saveConversationToLocal();

                        // Reset export tracking since we just loaded a file
                        lastExportedState = null;
                        hasUnsavedChangesFlag = false;

                        currentPage = 1;
                        renderPage();
                        renderAttachments();
                        updateStatus(
                            `Imported conversation (${conversationPairs.length} pairs, ${attachedFiles.length} attachment(s)).`,
                            "success",
                        );
                    } catch (err) {
                        console.error(err);
                        updateStatus(
                            "Error importing file: " + err.message,
                            "error",
                        );
                    }
                };
                reader.readAsText(file);
            }

            newChatBtn.addEventListener("click", newChat);
            exportBtn.addEventListener("click", exportConversation);
            importBtn.addEventListener("click", () => importFileInput.click());
            importFileInput.addEventListener("change", (e) => {
                const file = e.target.files?.[0];
                if (file) importConversation(file);
                importFileInput.value = "";
            });

            // ========= SEND MESSAGE =========
            async function sendMessage() {
                const text = userInput.value.trim();
                if (!text) return;

                const apiKey = getApiKey();
                if (!apiKey) {
                    updateStatus(
                        "Error: Please enter your API key above.",
                        "error",
                    );
                    return;
                }

                // Create new AbortController for this request
                currentAbortController = new AbortController();

                updateStatus("");
                showThinkingMessage(text);
                sendBtn.disabled = true;
                sendBtn.style.display = "none";
                stopBtn.style.display = "inline-block";
                const provider = providerSelect.value;
                const model = modelSelect.value;
                const context = getContextPrompt();

                try {
                    let assistantText = "";

                    // Gather attachments/files info (only included ones)
                    let fileInstructions = "";
                    const includedFiles = attachedFiles.filter(
                        (f) => f.include !== false,
                    );

                    // Separate binary files based on provider support
                    // Full support (base64): OpenAI (all)
                    // Limited support: Google (no DOCX), Anthropic (no DOCX)
                    // URL-only or no support: xAI, DeepSeek, Perplexity, Mistral (text fallback only)
                    let binaryFiles, textFiles;

                    if (
                        provider === "xai" ||
                        provider === "deepseek" ||
                        provider === "perplexity" ||
                        provider === "mistral"
                    ) {
                        // These providers don't support base64 file uploads - treat everything as text
                        binaryFiles = [];
                        textFiles = includedFiles;
                    } else if (
                        provider === "google" ||
                        provider === "anthropic"
                    ) {
                        // For Google/Anthropic: only PDF and images are binary, DOCX treated as text
                        binaryFiles = includedFiles.filter(
                            (f) => f.isPDF || f.isImage,
                        );
                        textFiles = includedFiles.filter(
                            (f) => !f.isPDF && !f.isImage,
                        );
                    } else {
                        // For OpenAI: PDF, DOCX, and images are binary
                        binaryFiles = includedFiles.filter(
                            (f) => f.isPDF || f.isDOCX || f.isImage,
                        );
                        textFiles = includedFiles.filter(
                            (f) => !f.isPDF && !f.isDOCX && !f.isImage,
                        );
                    }

                    // Build file instructions for non-binary files (text fallback)
                    if (textFiles.length > 0) {
                        const summary = textFiles
                            .map((f, idx) => `[FILE ${idx + 1}] ${f.name}`)
                            .join(", ");

                        fileInstructions =
                            `You have access to the following attached files in this conversation: ${summary}.\n` +
                            `When the user refers to a file by name or by [FILE n], use the corresponding file content provided in the system messages.`;

                        textFiles.forEach((f, idx) => {
                            if (!f.content) return;
                            fileInstructions += `\n\n[FILE ${idx + 1}] Name: ${f.name}\n\n${f.content}`;
                        });
                    }

                    // --- OPENAI LOGIC (RESPONSES API) ---
                    if (provider === "openai" && model === "gpt-image-1") {
                        // Use Images API for gpt-image-1
                        const requestBody = {
                            model: "gpt-image-1",
                            prompt: text,
                            n: 1,
                            size: "1024x1024", // Default size, can be made configurable
                        };

                        const response = await fetch(
                            "https://api.openai.com/v1/images/generations",
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                    Authorization: `Bearer ${apiKey}`,
                                },
                                body: JSON.stringify(requestBody),
                                signal: currentAbortController.signal,
                            },
                        );

                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(
                                `OpenAI Images API error: ${response.status} â€“ ${errText}`,
                            );
                        }

                        const data = await response.json();

                        // Extract image URL and format as markdown
                        const imageUrl = data.data?.[0]?.url;
                        if (imageUrl) {
                            assistantText = `![Generated image](${imageUrl})\n\n*Image generated with gpt-image-1*`;
                        } else {
                            assistantText =
                                "Error: No image URL returned from API";
                        }
                    } else if (provider === "openai") {
                        const apiInput = [];

                        // Build context from system prompts and conversation history
                        if (context || fileInstructions) {
                            const systemContent = [context, fileInstructions]
                                .filter(Boolean)
                                .join("\n\n");

                            if (systemContent) {
                                apiInput.push({
                                    role: "system",
                                    content: systemContent,
                                });
                            }
                        }

                        // Get pinned pairs (always included)
                        const pinnedPairs = conversationPairs.filter(
                            (p) => p.pinned === true,
                        );

                        // Get regular included pairs (excluding pinned ones)
                        const includedPairs = conversationPairs.filter(
                            (p) => p.include !== false && p.pinned !== true,
                        );
                        const recentPairs =
                            HISTORY_LIMIT === 0
                                ? includedPairs
                                : includedPairs.slice(-HISTORY_LIMIT);

                        // Add pinned pairs first
                        pinnedPairs.forEach((pair) => {
                            apiInput.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiInput.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Then add recent pairs
                        recentPairs.forEach((pair) => {
                            apiInput.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiInput.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Build user message with binary files (PDF/DOCX/Images) as vision content if present
                        if (binaryFiles.length > 0) {
                            const userContent = [
                                { type: "input_text", text: text },
                            ];

                            // Add each binary file with appropriate media type
                            binaryFiles.forEach((f) => {
                                if (f.content) {
                                    let mediaType;
                                    let contentType;

                                    if (f.isPDF) {
                                        mediaType = "application/pdf";
                                        contentType = "file";
                                    } else if (f.isDOCX) {
                                        mediaType =
                                            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                                        contentType = "file";
                                    } else if (f.isImage) {
                                        mediaType = f.type || "image/jpeg";
                                        contentType = "image";
                                    }

                                    if (contentType === "image") {
                                        userContent.push({
                                            type: "input_image",
                                            image_url: f.content, // Data URL string
                                        });
                                    } else {
                                        userContent.push({
                                            type: "input_file",
                                            file: {
                                                data: f.content.split(",")[1], // Base64 data only
                                                mime_type: mediaType,
                                            },
                                        });
                                    }
                                }
                            });

                            apiInput.push({
                                role: "user",
                                content: userContent,
                            });
                        } else {
                            apiInput.push({ role: "user", content: text });
                        }

                        // Get reasoning and verbosity settings from UI
                        const reasoningEffort = reasoningSelect.value || "none";
                        const verbosityLevel =
                            verbositySelect.value || "medium";

                        const requestBody = {
                            model: model,
                            input: apiInput,
                        };

                        // GPT-5 uses reasoning and verbosity, GPT-4 uses temperature
                        if (model.includes("gpt-5")) {
                            // Only include reasoning if effort is not "none"
                            // Some models (like gpt-5-nano, gpt-5-mini) don't support "none"
                            if (reasoningEffort !== "none") {
                                requestBody.reasoning = {
                                    effort: reasoningEffort,
                                };
                            }
                            requestBody.text = { verbosity: verbosityLevel };
                        } else if (model.includes("gpt-4")) {
                            // GPT-4 supports temperature
                            const temperature = parseFloat(
                                temperatureInput.value,
                            );
                            if (!isNaN(temperature)) {
                                requestBody.temperature = temperature;
                            }
                        }

                        // Add web search tool for GPT-5.1 and compatible models
                        // Exclude nano models as they don't support tools
                        if (
                            (model.includes("gpt-5") ||
                                model.includes("gpt-4")) &&
                            !model.includes("nano")
                        ) {
                            requestBody.tools = [
                                { type: "web_search_preview" },
                            ];
                        }

                        // Enable streaming
                        requestBody.stream = true;

                        const response = await fetch(
                            "https://api.openai.com/v1/responses",
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                    Authorization: `Bearer ${apiKey}`,
                                },
                                body: JSON.stringify(requestBody),
                                signal: currentAbortController.signal,
                            },
                        );

                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(
                                `OpenAI API error: ${response.status} â€“ ${errText}`,
                            );
                        }

                        // Handle streaming response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        // Get the assistant message bubble for streaming (not the user bubble)
                        const assistantRow = pendingAssistantNode.querySelector(
                            ".message-row.pending-assistant",
                        );
                        const streamingBubble = assistantRow.querySelector(
                            ".message-bubble.assistant",
                        );
                        streamingBubble.classList.remove("thinking");
                        streamingBubble.innerHTML = "";
                        assistantText = "";

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split("\n");
                            buffer = lines.pop() || "";

                            for (const line of lines) {
                                if (line.startsWith("data: ")) {
                                    const data = line.slice(6);
                                    if (data === "[DONE]") continue;

                                    try {
                                        const parsed = JSON.parse(data);

                                        // Handle different event types
                                        if (
                                            parsed.type ===
                                            "response.output_text.delta"
                                        ) {
                                            const delta = parsed.delta || "";
                                            assistantText += delta;
                                            streamingBubble.innerHTML =
                                                marked.parse(assistantText);
                                            enhanceCodeBlocks();
                                            messagesDiv.scrollTop =
                                                messagesDiv.scrollHeight;
                                        } else if (
                                            parsed.type ===
                                            "response.output_text.done"
                                        ) {
                                            // Final text if provided
                                            if (parsed.output_text) {
                                                assistantText =
                                                    parsed.output_text;
                                            }
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON
                                    }
                                }
                            }
                        }

                        assistantText = assistantText.trim();
                    }

                    // --- GOOGLE GEMINI LOGIC ---
                    else if (provider === "google") {
                        // Get pinned pairs (always included)
                        const pinnedPairs = conversationPairs.filter(
                            (p) => p.pinned === true,
                        );

                        // Get regular included pairs (excluding pinned ones)
                        const includedPairs = conversationPairs.filter(
                            (p) => p.include !== false && p.pinned !== true,
                        );
                        const recentPairs =
                            HISTORY_LIMIT === 0
                                ? includedPairs
                                : includedPairs.slice(-HISTORY_LIMIT);

                        const contents = [];

                        // Add pinned pairs first
                        pinnedPairs.forEach((pair) => {
                            contents.push({
                                role: "user",
                                parts: [{ text: pair.user }],
                            });
                            contents.push({
                                role: "model",
                                parts: [{ text: pair.assistant }],
                            });
                        });

                        // Then add recent pairs
                        recentPairs.forEach((pair) => {
                            contents.push({
                                role: "user",
                                parts: [{ text: pair.user }],
                            });
                            contents.push({
                                role: "model",
                                parts: [{ text: pair.assistant }],
                            });
                        });

                        // Build user message with binary files (PDF/DOCX/Images) as inline data if present
                        const userParts = [{ text: text }];

                        if (binaryFiles.length > 0) {
                            binaryFiles.forEach((f) => {
                                if (f.content) {
                                    let mimeType;

                                    if (f.isPDF) {
                                        mimeType = "application/pdf";
                                    } else if (f.isDOCX) {
                                        mimeType =
                                            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                                    } else if (f.isImage) {
                                        mimeType = f.type || "image/jpeg";
                                    }

                                    userParts.push({
                                        inline_data: {
                                            mime_type: mimeType,
                                            data: f.content.split(",")[1], // Remove data URL prefix
                                        },
                                    });
                                }
                            });
                        }

                        contents.push({
                            role: "user",
                            parts: userParts,
                        });

                        // Construct system instruction
                        let fullSystemInstruction = context || "";
                        if (fileInstructions) {
                            fullSystemInstruction += "\n\n" + fileInstructions;
                        }

                        const payload = {
                            contents: contents,
                        };

                        if (fullSystemInstruction.trim()) {
                            payload.system_instruction = {
                                parts: [{ text: fullSystemInstruction }],
                            };
                        }

                        // Add tools for Gemini models
                        // Check if it's an image model first
                        const isImageModel =
                            model === "gemini-2.5-flash-image" ||
                            model === "gemini-3-pro-image-preview";

                        const tools = [];

                        // Only add tools for non-image models
                        if (!isImageModel) {
                            // Add Google Search grounding (works on stable models: gemini-3, gemini-2.5, gemini-2.0, gemini-1.5)
                            if (
                                model.includes("gemini-3") ||
                                model.includes("gemini-2") ||
                                model.includes("gemini-1")
                            ) {
                                tools.push({ google_search: {} });
                            }

                            // Add code execution tool (available on all non-image Gemini models)
                            tools.push({ code_execution: {} });
                        }

                        if (tools.length > 0) {
                            payload.tools = tools;
                        }

                        // Add generation config with temperature
                        const temperature = parseFloat(temperatureInput.value);
                        if (!isNaN(temperature)) {
                            payload.generationConfig = {
                                temperature: temperature,
                            };
                        }

                        if (isImageModel) {
                            // Enable image generation response
                            payload.generationConfig =
                                payload.generationConfig || {};
                            payload.generationConfig.response_modalities = [
                                "TEXT",
                                "IMAGE",
                            ];
                        }

                        const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?key=${apiKey}&alt=sse`;

                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify(payload),
                            signal: currentAbortController.signal,
                        });

                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(
                                `Google API error: ${response.status} â€“ ${errText}`,
                            );
                        }

                        // Handle streaming response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        const assistantRow = pendingAssistantNode.querySelector(
                            ".message-row.pending-assistant",
                        );
                        const streamingBubble = assistantRow.querySelector(
                            ".message-bubble.assistant",
                        );
                        streamingBubble.classList.remove("thinking");
                        streamingBubble.innerHTML = "";
                        assistantText = "";
                        const textParts = [];

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split("\n");
                            buffer = lines.pop() || "";

                            for (const line of lines) {
                                if (line.startsWith("data: ")) {
                                    const data = line.slice(6);

                                    try {
                                        const parsed = JSON.parse(data);
                                        const candidates =
                                            parsed.candidates || [];

                                        if (
                                            candidates.length > 0 &&
                                            candidates[0].content &&
                                            candidates[0].content.parts
                                        ) {
                                            const parts =
                                                candidates[0].content.parts;

                                            parts.forEach((part) => {
                                                if (part.text) {
                                                    assistantText += part.text;
                                                } else if (part.inlineData) {
                                                    const mimeType =
                                                        part.inlineData
                                                            .mimeType ||
                                                        "image/png";
                                                    const base64Data =
                                                        part.inlineData.data;
                                                    const dataUrl = `data:${mimeType};base64,${base64Data}`;
                                                    assistantText += `\n\n![Generated image](${dataUrl})\n\n`;
                                                } else if (part.inline_data) {
                                                    const mimeType =
                                                        part.inline_data
                                                            .mime_type ||
                                                        "image/png";
                                                    const base64Data =
                                                        part.inline_data.data;
                                                    const dataUrl = `data:${mimeType};base64,${base64Data}`;
                                                    assistantText += `\n\n![Generated image](${dataUrl})\n\n`;
                                                }
                                            });

                                            streamingBubble.innerHTML =
                                                marked.parse(assistantText);
                                            enhanceCodeBlocks();
                                            messagesDiv.scrollTop =
                                                messagesDiv.scrollHeight;
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON
                                    }
                                }
                            }
                        }

                        assistantText = assistantText.trim();
                        if (!assistantText) {
                            assistantText = "(No content returned)";
                        }
                    }

                    // --- XAI GROK LOGIC ---
                    else if (provider === "xai") {
                        const apiMessages = [];

                        if (context) {
                            apiMessages.push({
                                role: "system",
                                content: context,
                            });
                        }

                        if (fileInstructions) {
                            apiMessages.push({
                                role: "system",
                                content: fileInstructions,
                            });
                        }

                        // Get pinned pairs (always included)
                        const pinnedPairs = conversationPairs.filter(
                            (p) => p.pinned === true,
                        );

                        // Get regular included pairs (excluding pinned ones)
                        const includedPairs = conversationPairs.filter(
                            (p) => p.include !== false && p.pinned !== true,
                        );
                        const recentPairs =
                            HISTORY_LIMIT === 0
                                ? includedPairs
                                : includedPairs.slice(-HISTORY_LIMIT);

                        // Add pinned pairs first
                        pinnedPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Then add recent pairs
                        recentPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Build user message with binary files if present (OpenAI-compatible format)
                        if (binaryFiles.length > 0) {
                            const userContent = [{ type: "text", text: text }];

                            binaryFiles.forEach((f) => {
                                if (f.content) {
                                    let mediaType;
                                    let contentType;

                                    if (f.isPDF) {
                                        mediaType = "application/pdf";
                                        contentType = "document";
                                    } else if (f.isDOCX) {
                                        mediaType =
                                            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                                        contentType = "document";
                                    } else if (f.isImage) {
                                        mediaType = f.type || "image/jpeg";
                                        contentType = "image";
                                    }

                                    if (contentType === "image") {
                                        userContent.push({
                                            type: "image_url",
                                            image_url: {
                                                url: f.content, // Full data URL
                                            },
                                        });
                                    } else {
                                        userContent.push({
                                            type: "document",
                                            source: {
                                                type: "base64",
                                                media_type: mediaType,
                                                data: f.content.split(",")[1],
                                            },
                                        });
                                    }
                                }
                            });

                            apiMessages.push({
                                role: "user",
                                content: userContent,
                            });
                        } else {
                            apiMessages.push({ role: "user", content: text });
                        }

                        const response = await fetch(
                            "https://api.x.ai/v1/chat/completions",
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                    Authorization: `Bearer ${apiKey}`,
                                },
                                body: JSON.stringify({
                                    model: model,
                                    messages: apiMessages,
                                    temperature:
                                        parseFloat(temperatureInput.value) ||
                                        1.0,
                                    stream: true,
                                }),
                                signal: currentAbortController.signal,
                            },
                        );

                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(
                                `xAI API error: ${response.status} â€“ ${errText}`,
                            );
                        }

                        // Handle streaming response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        const assistantRow = pendingAssistantNode.querySelector(
                            ".message-row.pending-assistant",
                        );
                        const streamingBubble = assistantRow.querySelector(
                            ".message-bubble.assistant",
                        );
                        streamingBubble.classList.remove("thinking");
                        streamingBubble.innerHTML = "";
                        assistantText = "";

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split("\n");
                            buffer = lines.pop() || "";

                            for (const line of lines) {
                                if (line.startsWith("data: ")) {
                                    const data = line.slice(6);
                                    if (data === "[DONE]") continue;

                                    try {
                                        const parsed = JSON.parse(data);
                                        const delta =
                                            parsed.choices?.[0]?.delta?.content;
                                        if (delta) {
                                            assistantText += delta;
                                            streamingBubble.innerHTML =
                                                marked.parse(assistantText);
                                            enhanceCodeBlocks();
                                            messagesDiv.scrollTop =
                                                messagesDiv.scrollHeight;
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON
                                    }
                                }
                            }
                        }

                        assistantText = assistantText.trim();
                    }

                    // --- ANTHROPIC CLAUDE LOGIC ---
                    else if (provider === "anthropic") {
                        const apiMessages = [];

                        // Get pinned pairs (always included)
                        const pinnedPairs = conversationPairs.filter(
                            (p) => p.pinned === true,
                        );

                        // Get regular included pairs (excluding pinned ones)
                        const includedPairs = conversationPairs.filter(
                            (p) => p.include !== false && p.pinned !== true,
                        );
                        const recentPairs =
                            HISTORY_LIMIT === 0
                                ? includedPairs
                                : includedPairs.slice(-HISTORY_LIMIT);

                        // Add pinned pairs first
                        pinnedPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Then add recent pairs
                        recentPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Build user message with binary files (PDF/DOCX/Images) if present
                        if (binaryFiles.length > 0) {
                            const userContent = [{ type: "text", text: text }];

                            binaryFiles.forEach((f) => {
                                if (f.content) {
                                    let mediaType;
                                    let contentType;

                                    if (f.isPDF) {
                                        mediaType = "application/pdf";
                                        contentType = "document";
                                    } else if (f.isDOCX) {
                                        mediaType =
                                            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                                        contentType = "document";
                                    } else if (f.isImage) {
                                        mediaType = f.type || "image/jpeg";
                                        contentType = "image";
                                    }

                                    if (contentType === "image") {
                                        userContent.push({
                                            type: "image",
                                            source: {
                                                type: "base64",
                                                media_type: mediaType,
                                                data: f.content.split(",")[1], // Remove data URL prefix
                                            },
                                        });
                                    } else {
                                        userContent.push({
                                            type: "document",
                                            source: {
                                                type: "base64",
                                                media_type: mediaType,
                                                data: f.content.split(",")[1], // Remove data URL prefix
                                            },
                                        });
                                    }
                                }
                            });

                            apiMessages.push({
                                role: "user",
                                content: userContent,
                            });
                        } else {
                            apiMessages.push({ role: "user", content: text });
                        }

                        const payload = {
                            model: model,
                            max_tokens: 8192,
                            messages: apiMessages,
                        };

                        // Construct system prompt
                        let fullSystemPrompt = context || "";
                        if (fileInstructions) {
                            fullSystemPrompt += "\n\n" + fileInstructions;
                        }

                        if (fullSystemPrompt.trim()) {
                            payload.system = fullSystemPrompt;
                        }

                        // Add tools for Claude models (Opus 4.5, Sonnet, etc.)
                        const tools = [
                            {
                                type: "computer_20250124",
                                name: "computer",
                                display_width_px: 1024,
                                display_height_px: 768,
                            },
                            {
                                type: "text_editor_20250728",
                                name: "str_replace_based_edit_tool",
                            },
                            {
                                type: "bash_20250124",
                                name: "bash",
                            },
                            {
                                type: "web_search_20250305",
                                name: "web_search",
                            },
                        ];

                        payload.tools = tools;

                        // Add temperature parameter
                        const temperature = parseFloat(temperatureInput.value);
                        if (!isNaN(temperature)) {
                            payload.temperature = temperature;
                        }

                        // Enable streaming
                        payload.stream = true;

                        const headers = {
                            "Content-Type": "application/json",
                            "x-api-key": apiKey,
                            "anthropic-version": "2023-06-01",
                            "anthropic-dangerous-direct-browser-access": "true",
                        };

                        // Add beta headers for computer use, advanced tool use, and streaming
                        headers["anthropic-beta"] =
                            "computer-use-2025-01-24,advanced-tool-use-2025-11-20,fine-grained-tool-streaming-2025-05-14";

                        const response = await fetch(
                            "https://api.anthropic.com/v1/messages",
                            {
                                method: "POST",
                                headers: headers,
                                body: JSON.stringify(payload),
                                signal: currentAbortController.signal,
                            },
                        );

                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(
                                `Anthropic API error: ${response.status} â€“ ${errText}`,
                            );
                        }

                        // Handle streaming response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        const assistantRow = pendingAssistantNode.querySelector(
                            ".message-row.pending-assistant",
                        );
                        const streamingBubble = assistantRow.querySelector(
                            ".message-bubble.assistant",
                        );
                        streamingBubble.classList.remove("thinking");
                        streamingBubble.innerHTML = "";
                        assistantText = "";

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split("\n");
                            buffer = lines.pop() || "";

                            for (const line of lines) {
                                if (line.startsWith("data: ")) {
                                    const data = line.slice(6);

                                    try {
                                        const parsed = JSON.parse(data);

                                        // Handle content_block_delta events
                                        if (
                                            parsed.type ===
                                            "content_block_delta"
                                        ) {
                                            if (
                                                parsed.delta &&
                                                parsed.delta.type ===
                                                    "text_delta"
                                            ) {
                                                assistantText +=
                                                    parsed.delta.text;
                                                streamingBubble.innerHTML =
                                                    marked.parse(assistantText);
                                                enhanceCodeBlocks();
                                                messagesDiv.scrollTop =
                                                    messagesDiv.scrollHeight;
                                            }
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON
                                    }
                                }
                            }
                        }

                        assistantText = assistantText.trim();
                        if (!assistantText) {
                            assistantText = "(No content returned)";
                        }
                    } else if (provider === "deepseek") {
                        const apiMessages = [];

                        // Get pinned pairs (always included)
                        const pinnedPairs = conversationPairs.filter(
                            (p) => p.pinned === true,
                        );

                        // Get regular included pairs (excluding pinned ones)
                        const includedPairs = conversationPairs.filter(
                            (p) => p.include !== false && p.pinned !== true,
                        );
                        const recentPairs =
                            HISTORY_LIMIT === 0
                                ? includedPairs
                                : includedPairs.slice(-HISTORY_LIMIT);

                        // Add pinned pairs first
                        pinnedPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Then add recent pairs
                        recentPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Build user message with binary files if present (OpenAI-compatible format)
                        if (binaryFiles.length > 0) {
                            const userContent = [{ type: "text", text: text }];

                            binaryFiles.forEach((f) => {
                                if (f.content) {
                                    let mediaType;
                                    let contentType;

                                    if (f.isPDF) {
                                        mediaType = "application/pdf";
                                        contentType = "document";
                                    } else if (f.isDOCX) {
                                        mediaType =
                                            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                                        contentType = "document";
                                    } else if (f.isImage) {
                                        mediaType = f.type || "image/jpeg";
                                        contentType = "image";
                                    }

                                    if (contentType === "image") {
                                        userContent.push({
                                            type: "image_url",
                                            image_url: {
                                                url: f.content, // Full data URL
                                            },
                                        });
                                    } else {
                                        userContent.push({
                                            type: "document",
                                            source: {
                                                type: "base64",
                                                media_type: mediaType,
                                                data: f.content.split(",")[1],
                                            },
                                        });
                                    }
                                }
                            });

                            apiMessages.push({
                                role: "user",
                                content: userContent,
                            });
                        } else {
                            apiMessages.push({ role: "user", content: text });
                        }

                        // Construct system prompt
                        let fullSystemPrompt = context || "";
                        if (fileInstructions) {
                            fullSystemPrompt += "\n\n" + fileInstructions;
                        }

                        if (fullSystemPrompt.trim()) {
                            apiMessages.unshift({
                                role: "system",
                                content: fullSystemPrompt,
                            });
                        }

                        const payload = {
                            model: model,
                            messages: apiMessages,
                            stream: true,
                        };

                        // Add temperature parameter
                        const temperature = parseFloat(temperatureInput.value);
                        if (!isNaN(temperature)) {
                            payload.temperature = temperature;
                        }

                        const headers = {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${apiKey}`,
                        };

                        const response = await fetch(
                            "https://api.deepseek.com/v1/chat/completions",
                            {
                                method: "POST",
                                headers: headers,
                                body: JSON.stringify(payload),
                                signal: currentAbortController.signal,
                            },
                        );

                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(
                                `DeepSeek API error: ${response.status} â€“ ${errText}`,
                            );
                        }

                        // Handle streaming response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        const assistantRow = pendingAssistantNode.querySelector(
                            ".message-row.pending-assistant",
                        );
                        const streamingBubble = assistantRow.querySelector(
                            ".message-bubble.assistant",
                        );
                        streamingBubble.classList.remove("thinking");
                        streamingBubble.innerHTML = "";
                        assistantText = "";

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split("\n");
                            buffer = lines.pop() || "";

                            for (const line of lines) {
                                if (line.startsWith("data: ")) {
                                    const data = line.slice(6);
                                    if (data === "[DONE]") continue;

                                    try {
                                        const parsed = JSON.parse(data);
                                        const delta =
                                            parsed.choices?.[0]?.delta?.content;
                                        if (delta) {
                                            assistantText += delta;
                                            streamingBubble.innerHTML =
                                                marked.parse(assistantText);
                                            enhanceCodeBlocks();
                                            messagesDiv.scrollTop =
                                                messagesDiv.scrollHeight;
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON
                                    }
                                }
                            }
                        }

                        assistantText = assistantText.trim();
                        if (!assistantText) {
                            assistantText = "(No content returned)";
                        }
                    } else if (provider === "perplexity") {
                        const apiMessages = [];

                        // Get pinned pairs (always included)
                        const pinnedPairs = conversationPairs.filter(
                            (p) => p.pinned === true,
                        );

                        // Get regular included pairs (excluding pinned ones)
                        const includedPairs = conversationPairs.filter(
                            (p) => p.include !== false && p.pinned !== true,
                        );
                        const recentPairs =
                            HISTORY_LIMIT === 0
                                ? includedPairs
                                : includedPairs.slice(-HISTORY_LIMIT);

                        // Add pinned pairs first
                        pinnedPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Then add recent pairs
                        recentPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Build user message with binary files if present (OpenAI-compatible format)
                        if (binaryFiles.length > 0) {
                            const userContent = [{ type: "text", text: text }];

                            binaryFiles.forEach((f) => {
                                if (f.content) {
                                    let mediaType;
                                    let contentType;

                                    if (f.isPDF) {
                                        mediaType = "application/pdf";
                                        contentType = "document";
                                    } else if (f.isDOCX) {
                                        mediaType =
                                            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                                        contentType = "document";
                                    } else if (f.isImage) {
                                        mediaType = f.type || "image/jpeg";
                                        contentType = "image";
                                    }

                                    if (contentType === "image") {
                                        userContent.push({
                                            type: "image_url",
                                            image_url: {
                                                url: f.content, // Full data URL
                                            },
                                        });
                                    } else {
                                        userContent.push({
                                            type: "document",
                                            source: {
                                                type: "base64",
                                                media_type: mediaType,
                                                data: f.content.split(",")[1],
                                            },
                                        });
                                    }
                                }
                            });

                            apiMessages.push({
                                role: "user",
                                content: userContent,
                            });
                        } else {
                            apiMessages.push({ role: "user", content: text });
                        }

                        // Construct system prompt
                        let fullSystemPrompt = context || "";
                        if (fileInstructions) {
                            fullSystemPrompt += "\n\n" + fileInstructions;
                        }

                        if (fullSystemPrompt.trim()) {
                            apiMessages.unshift({
                                role: "system",
                                content: fullSystemPrompt,
                            });
                        }

                        const payload = {
                            model: model,
                            messages: apiMessages,
                            stream: true,
                        };

                        // Add temperature parameter
                        const temperature = parseFloat(temperatureInput.value);
                        if (!isNaN(temperature)) {
                            payload.temperature = temperature;
                        }

                        const headers = {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${apiKey}`,
                        };

                        const response = await fetch(
                            "https://api.perplexity.ai/chat/completions",
                            {
                                method: "POST",
                                headers: headers,
                                body: JSON.stringify(payload),
                                signal: currentAbortController.signal,
                            },
                        );

                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(
                                `Perplexity API error: ${response.status} â€“ ${errText}`,
                            );
                        }

                        // Handle streaming response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        const assistantRow = pendingAssistantNode.querySelector(
                            ".message-row.pending-assistant",
                        );
                        const streamingBubble = assistantRow.querySelector(
                            ".message-bubble.assistant",
                        );
                        streamingBubble.classList.remove("thinking");
                        streamingBubble.innerHTML = "";
                        assistantText = "";

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split("\n");
                            buffer = lines.pop() || "";

                            for (const line of lines) {
                                if (line.startsWith("data: ")) {
                                    const data = line.slice(6);
                                    if (data === "[DONE]") continue;

                                    try {
                                        const parsed = JSON.parse(data);
                                        const delta =
                                            parsed.choices?.[0]?.delta?.content;
                                        if (delta) {
                                            assistantText += delta;
                                            streamingBubble.innerHTML =
                                                marked.parse(assistantText);
                                            enhanceCodeBlocks();
                                            messagesDiv.scrollTop =
                                                messagesDiv.scrollHeight;
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON
                                    }
                                }
                            }
                        }

                        assistantText = assistantText.trim();
                        if (!assistantText) {
                            assistantText = "(No content returned)";
                        }
                    } else if (provider === "mistral") {
                        const apiMessages = [];

                        // Get pinned pairs (always included)
                        const pinnedPairs = conversationPairs.filter(
                            (p) => p.pinned === true,
                        );

                        // Get regular included pairs (excluding pinned ones)
                        const includedPairs = conversationPairs.filter(
                            (p) => p.include !== false && p.pinned !== true,
                        );
                        const recentPairs =
                            HISTORY_LIMIT === 0
                                ? includedPairs
                                : includedPairs.slice(-HISTORY_LIMIT);

                        // Add pinned pairs first
                        pinnedPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Then add recent pairs
                        recentPairs.forEach((pair) => {
                            apiMessages.push({
                                role: "user",
                                content: pair.user,
                            });
                            apiMessages.push({
                                role: "assistant",
                                content: pair.assistant,
                            });
                        });

                        // Build user message with binary files if present (OpenAI-compatible format)
                        if (binaryFiles.length > 0) {
                            const userContent = [{ type: "text", text: text }];

                            binaryFiles.forEach((f) => {
                                if (f.content) {
                                    let mediaType;
                                    let contentType;

                                    if (f.isPDF) {
                                        mediaType = "application/pdf";
                                        contentType = "document";
                                    } else if (f.isDOCX) {
                                        mediaType =
                                            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                                        contentType = "document";
                                    } else if (f.isImage) {
                                        mediaType = f.type || "image/jpeg";
                                        contentType = "image";
                                    }

                                    if (contentType === "image") {
                                        userContent.push({
                                            type: "image_url",
                                            image_url: {
                                                url: f.content, // Full data URL
                                            },
                                        });
                                    } else {
                                        userContent.push({
                                            type: "document",
                                            source: {
                                                type: "base64",
                                                media_type: mediaType,
                                                data: f.content.split(",")[1],
                                            },
                                        });
                                    }
                                }
                            });

                            apiMessages.push({
                                role: "user",
                                content: userContent,
                            });
                        } else {
                            apiMessages.push({ role: "user", content: text });
                        }

                        // Construct system prompt
                        let fullSystemPrompt = context || "";
                        if (fileInstructions) {
                            fullSystemPrompt += "\n\n" + fileInstructions;
                        }

                        if (fullSystemPrompt.trim()) {
                            apiMessages.unshift({
                                role: "system",
                                content: fullSystemPrompt,
                            });
                        }

                        const payload = {
                            model: model,
                            messages: apiMessages,
                            stream: true,
                        };

                        // Add temperature parameter
                        const temperature = parseFloat(temperatureInput.value);
                        if (!isNaN(temperature)) {
                            payload.temperature = temperature;
                        }

                        const headers = {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${apiKey}`,
                        };

                        const response = await fetch(
                            "https://api.mistral.ai/v1/chat/completions",
                            {
                                method: "POST",
                                headers: headers,
                                body: JSON.stringify(payload),
                                signal: currentAbortController.signal,
                            },
                        );

                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(
                                `Mistral API error: ${response.status} â€“ ${errText}`,
                            );
                        }

                        // Handle streaming response
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        const assistantRow = pendingAssistantNode.querySelector(
                            ".message-row.pending-assistant",
                        );
                        const streamingBubble = assistantRow.querySelector(
                            ".message-bubble.assistant",
                        );
                        streamingBubble.classList.remove("thinking");
                        streamingBubble.innerHTML = "";
                        assistantText = "";

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split("\n");
                            buffer = lines.pop() || "";

                            for (const line of lines) {
                                if (line.startsWith("data: ")) {
                                    const data = line.slice(6);
                                    if (data === "[DONE]") continue;

                                    try {
                                        const parsed = JSON.parse(data);
                                        const delta =
                                            parsed.choices?.[0]?.delta?.content;
                                        if (delta) {
                                            assistantText += delta;
                                            streamingBubble.innerHTML =
                                                marked.parse(assistantText);
                                            enhanceCodeBlocks();
                                            messagesDiv.scrollTop =
                                                messagesDiv.scrollHeight;
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON
                                    }
                                }
                            }
                        }

                        assistantText = assistantText.trim();
                        if (!assistantText) {
                            assistantText = "(No content returned)";
                        }
                    }

                    // Calculate final elapsed time
                    const finalElapsedMs = thinkingStartTime
                        ? Date.now() - thinkingStartTime
                        : null;

                    hideThinkingMessage();

                    conversationPairs.push({
                        user: text,
                        assistant: assistantText,
                        t: Date.now(),
                        include: true,
                        collapsed: false,
                        provider: provider,
                        elapsedMs: finalElapsedMs,
                    });

                    saveConversationToLocal();

                    currentPage = 1;
                    userInput.value = "";
                    autoResizeInput();
                    updateStatus("");
                    renderPage();
                } catch (err) {
                    console.error(err);
                    hideThinkingMessage();

                    // Check if request was aborted by user
                    if (err.name === "AbortError") {
                        updateStatus("Request cancelled by user.", "warning");
                    } else {
                        updateStatus("Error: " + err.message, "error");
                    }
                } finally {
                    sendBtn.disabled = false;
                    sendBtn.style.display = "inline-block";
                    stopBtn.style.display = "none";
                    currentAbortController = null;
                    userInput.focus();
                }
            }

            sendBtn.addEventListener("click", sendMessage);

            stopBtn.addEventListener("click", () => {
                if (currentAbortController) {
                    currentAbortController.abort();
                    updateStatus("Cancelling request...", "warning");
                }
            });

            // Status log dropdown toggle
            statusDot.addEventListener("click", (e) => {
                e.stopPropagation();
                statusLogDropdown.classList.toggle("visible");
                if (statusLogDropdown.classList.contains("visible")) {
                    renderStatusLog();
                }
            });

            // Clear log button
            clearLogBtn.addEventListener("click", () => {
                statusLog = [];
                renderStatusLog();
            });

            // Close dropdown when clicking outside
            document.addEventListener("click", (e) => {
                if (
                    !statusLogDropdown.contains(e.target) &&
                    e.target !== statusDot
                ) {
                    statusLogDropdown.classList.remove("visible");
                }
            });

            userInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            userInput.addEventListener("input", autoResizeInput);

            function autoResizeInput() {
                userInput.style.height = "auto";
                userInput.style.height = userInput.scrollHeight + "px";
            }

            // ========= BACK TO TOP BUTTON =========
            messagesDiv.addEventListener("scroll", () => {
                // Show button if scrolled down more than 200px
                if (messagesDiv.scrollTop > 200) {
                    backToTopBtn.classList.add("show");
                } else {
                    backToTopBtn.classList.remove("show");
                }
            });

            backToTopBtn.addEventListener("click", () => {
                messagesDiv.scrollTo({
                    top: 0,
                    behavior: "smooth",
                });
            });

            // ========= INIT =========
            loadContextPrompt();
            loadChatName();
            loadApiKeys();
            loadProviderAndModel();
            loadUserAvatar();
            loadAssistantAvatars();
            updateApiKeyStatus();
            loadHistoryLimit();
            loadPageSize();
            updateHistoryLimitDisplay();
            updatePageSizeDisplay();
            loadConversationFromLocal();
            autoResizeInput();
            renderPage();
            renderAttachments();

            // Validate API keys in background
            validateAllKeys();
        </script>
    </body>
</html>
